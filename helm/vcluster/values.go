// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package vcluster

// APIService holds configuration related to the api server
type APIService struct {
	// Service is a reference to the service for the API server.
	Service *APIServiceService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

// APIServiceService holds the service name and namespace of the host apiservice.
type APIServiceService struct {
	// Name is the name of the host service of the apiservice.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace is the name of the host service of the apiservice.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Port is the target port on the host service to connect to.
	Port *int `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
}

// AutoSleepExclusion holds conifiguration for excluding workloads from sleeping by
// label(s)
type AutoSleepExclusion struct {
	// Selector corresponds to the JSON schema field "selector".
	Selector *LabelSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`
}

// AutoWakeup holds the cron schedule to wake workloads automatically
type AutoWakeup struct {
	// Schedule corresponds to the JSON schema field "schedule".
	Schedule *string `json:"schedule,omitempty" yaml:"schedule,omitempty" mapstructure:"schedule,omitempty"`
}

type BackingStore struct {
	// Database defines that a database backend should be used as the backend for the
	// virtual cluster. This uses a project called kine under the hood which is a shim
	// for bridging Kubernetes and relational databases.
	Database *Database `json:"database,omitempty" yaml:"database,omitempty" mapstructure:"database,omitempty"`

	// Etcd defines that etcd should be used as the backend for the virtual cluster
	Etcd *Etcd `json:"etcd,omitempty" yaml:"etcd,omitempty" mapstructure:"etcd,omitempty"`
}

type CentralAdmission struct {
	// MutatingWebhooks are mutating webhooks that should be enforced in the virtual
	// cluster
	MutatingWebhooks []MutatingWebhookConfiguration `json:"mutatingWebhooks,omitempty" yaml:"mutatingWebhooks,omitempty" mapstructure:"mutatingWebhooks,omitempty"`

	// ValidatingWebhooks are validating webhooks that should be enforced in the
	// virtual cluster
	ValidatingWebhooks []ValidatingWebhookConfiguration `json:"validatingWebhooks,omitempty" yaml:"validatingWebhooks,omitempty" mapstructure:"validatingWebhooks,omitempty"`
}

// CertManager reuses a host cert-manager and makes its CRDs from it available
// inside the vCluster
type CertManager struct {
	// Enabled defines if this option should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Sync contains advanced configuration for syncing cert-manager resources.
	Sync *CertManagerSync `json:"sync,omitempty" yaml:"sync,omitempty" mapstructure:"sync,omitempty"`
}

type CertManagerSync struct {
	// FromHost corresponds to the JSON schema field "fromHost".
	FromHost *CertManagerSyncFromHost `json:"fromHost,omitempty" yaml:"fromHost,omitempty" mapstructure:"fromHost,omitempty"`

	// ToHost corresponds to the JSON schema field "toHost".
	ToHost *CertManagerSyncToHost `json:"toHost,omitempty" yaml:"toHost,omitempty" mapstructure:"toHost,omitempty"`
}

type CertManagerSyncFromHost struct {
	// ClusterIssuers defines if (and which) cluster issuers should get synced from
	// the host cluster to the virtual cluster.
	ClusterIssuers *ClusterIssuersSyncConfig `json:"clusterIssuers,omitempty" yaml:"clusterIssuers,omitempty" mapstructure:"clusterIssuers,omitempty"`
}

type CertManagerSyncToHost struct {
	// Certificates defines if certificates should get synced from the virtual cluster
	// to the host cluster.
	Certificates *EnableSwitch `json:"certificates,omitempty" yaml:"certificates,omitempty" mapstructure:"certificates,omitempty"`

	// Issuers defines if issuers should get synced from the virtual cluster to the
	// host cluster.
	Issuers *EnableSwitch `json:"issuers,omitempty" yaml:"issuers,omitempty" mapstructure:"issuers,omitempty"`
}

type ClusterIssuersSyncConfig struct {
	// Enabled defines if this option should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Selector defines what cluster issuers should be imported.
	Selector *LabelSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`
}

type ClusterStoresSyncConfig struct {
	// Enabled defines if this option should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Selector defines what cluster stores should be synced
	Selector *LabelSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`
}

type ControlPlane struct {
	// Advanced holds additional configuration for the vCluster control plane.
	Advanced *ControlPlaneAdvanced `json:"advanced,omitempty" yaml:"advanced,omitempty" mapstructure:"advanced,omitempty"`

	// BackingStore defines which backing store to use for virtual cluster. If not
	// defined will use embedded database as a default backing store.
	BackingStore *BackingStore `json:"backingStore,omitempty" yaml:"backingStore,omitempty" mapstructure:"backingStore,omitempty"`

	// CoreDNS defines everything related to the coredns that is deployed and used
	// within the vCluster.
	Coredns *CoreDNS `json:"coredns,omitempty" yaml:"coredns,omitempty" mapstructure:"coredns,omitempty"`

	// Distro holds virtual cluster related distro options. A distro cannot be changed
	// after vCluster is deployed.
	Distro *Distro `json:"distro,omitempty" yaml:"distro,omitempty" mapstructure:"distro,omitempty"`

	// HostPathMapper defines if vCluster should rewrite host paths.
	HostPathMapper *HostPathMapper `json:"hostPathMapper,omitempty" yaml:"hostPathMapper,omitempty" mapstructure:"hostPathMapper,omitempty"`

	// Ingress defines options for vCluster ingress deployed by Helm.
	Ingress *ControlPlaneIngress `json:"ingress,omitempty" yaml:"ingress,omitempty" mapstructure:"ingress,omitempty"`

	// Proxy defines options for the virtual cluster control plane proxy that is used
	// to do authentication and intercept requests.
	Proxy *ControlPlaneProxy `json:"proxy,omitempty" yaml:"proxy,omitempty" mapstructure:"proxy,omitempty"`

	// Service defines options for vCluster service deployed by Helm.
	Service *ControlPlaneService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// ServiceMonitor can be used to automatically create a service monitor for
	// vCluster deployment itself.
	ServiceMonitor *ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty" mapstructure:"serviceMonitor,omitempty"`

	// StatefulSet defines options for vCluster statefulSet deployed by Helm.
	StatefulSet *ControlPlaneStatefulSet `json:"statefulSet,omitempty" yaml:"statefulSet,omitempty" mapstructure:"statefulSet,omitempty"`
}

type ControlPlaneAdvanced struct {
	// DefaultImageRegistry will be used as a prefix for all internal images deployed
	// by vCluster or Helm. This makes it easy to
	// upload all required vCluster images to a single private repository and set this
	// value. Workload images are not affected by this.
	DefaultImageRegistry *string `json:"defaultImageRegistry,omitempty" yaml:"defaultImageRegistry,omitempty" mapstructure:"defaultImageRegistry,omitempty"`

	// GlobalMetadata is metadata that will be added to all resources deployed by
	// Helm.
	GlobalMetadata *ControlPlaneGlobalMetadata `json:"globalMetadata,omitempty" yaml:"globalMetadata,omitempty" mapstructure:"globalMetadata,omitempty"`

	// HeadlessService specifies options for the headless service used for the
	// vCluster StatefulSet.
	HeadlessService *ControlPlaneHeadlessService `json:"headlessService,omitempty" yaml:"headlessService,omitempty" mapstructure:"headlessService,omitempty"`

	// ServiceAccount specifies options for the vCluster control plane service
	// account.
	ServiceAccount *ControlPlaneServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`

	// VirtualScheduler defines if a scheduler should be used within the virtual
	// cluster or the scheduling decision for workloads will be made by the host
	// cluster.
	VirtualScheduler *EnableSwitch `json:"virtualScheduler,omitempty" yaml:"virtualScheduler,omitempty" mapstructure:"virtualScheduler,omitempty"`

	// WorkloadServiceAccount specifies options for the service account that will be
	// used for the workloads that run within the virtual cluster.
	WorkloadServiceAccount *ControlPlaneWorkloadServiceAccount `json:"workloadServiceAccount,omitempty" yaml:"workloadServiceAccount,omitempty" mapstructure:"workloadServiceAccount,omitempty"`
}

type ControlPlaneGlobalMetadata struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneGlobalMetadataAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneGlobalMetadataAnnotations map[string]string

type ControlPlaneHeadlessService struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneHeadlessServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneHeadlessServiceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneHeadlessServiceAnnotations map[string]string

// Labels are extra labels for this resource.
type ControlPlaneHeadlessServiceLabels map[string]string

type ControlPlaneHighAvailability struct {
	// LeaseDuration is the time to lease for the leader.
	LeaseDuration *int `json:"leaseDuration,omitempty" yaml:"leaseDuration,omitempty" mapstructure:"leaseDuration,omitempty"`

	// RenewDeadline is the deadline to renew a lease for the leader.
	RenewDeadline *int `json:"renewDeadline,omitempty" yaml:"renewDeadline,omitempty" mapstructure:"renewDeadline,omitempty"`

	// Replicas is the amount of replicas to use for the statefulSet.
	Replicas *int `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`

	// RetryPeriod is the time until a replica will retry to get a lease.
	RetryPeriod *int `json:"retryPeriod,omitempty" yaml:"retryPeriod,omitempty" mapstructure:"retryPeriod,omitempty"`
}

type ControlPlaneIngress struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneIngressAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the control plane ingress should be enabled
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Host is the host where vCluster will be reachable
	Host *string `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneIngressLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// PathType is the path type of the ingress
	PathType *string `json:"pathType,omitempty" yaml:"pathType,omitempty" mapstructure:"pathType,omitempty"`

	// Spec allows you to configure extra ingress options.
	Spec ControlPlaneIngressSpec `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneIngressAnnotations map[string]string

// Labels are extra labels for this resource.
type ControlPlaneIngressLabels map[string]string

// Spec allows you to configure extra ingress options.
type ControlPlaneIngressSpec map[string]interface{}

type ControlPlanePersistence struct {
	// AddVolumeMounts defines extra volume mounts for the container
	AddVolumeMounts []VolumeMount `json:"addVolumeMounts,omitempty" yaml:"addVolumeMounts,omitempty" mapstructure:"addVolumeMounts,omitempty"`

	// AddVolumes defines extra volumes for the pod
	AddVolumes []ControlPlanePersistenceAddVolumesElem `json:"addVolumes,omitempty" yaml:"addVolumes,omitempty" mapstructure:"addVolumes,omitempty"`

	// BinariesVolume defines a binaries volume that is used to retrieve
	// distro specific executables to be run by the syncer controller.
	// This volume doesn't need to be persistent.
	BinariesVolume []ControlPlanePersistenceBinariesVolumeElem `json:"binariesVolume,omitempty" yaml:"binariesVolume,omitempty" mapstructure:"binariesVolume,omitempty"`

	// Allows you to override the dataVolume. Only works correctly if
	// volumeClaim.enabled=false.
	DataVolume []ControlPlanePersistenceDataVolumeElem `json:"dataVolume,omitempty" yaml:"dataVolume,omitempty" mapstructure:"dataVolume,omitempty"`

	// VolumeClaim can be used to configure the persistent volume claim.
	VolumeClaim *VolumeClaim `json:"volumeClaim,omitempty" yaml:"volumeClaim,omitempty" mapstructure:"volumeClaim,omitempty"`

	// VolumeClaimTemplates defines the volumeClaimTemplates for the statefulSet
	VolumeClaimTemplates []ControlPlanePersistenceVolumeClaimTemplatesElem `json:"volumeClaimTemplates,omitempty" yaml:"volumeClaimTemplates,omitempty" mapstructure:"volumeClaimTemplates,omitempty"`
}

type ControlPlanePersistenceAddVolumesElem map[string]interface{}

type ControlPlanePersistenceBinariesVolumeElem map[string]interface{}

type ControlPlanePersistenceDataVolumeElem map[string]interface{}

type ControlPlanePersistenceVolumeClaimTemplatesElem map[string]interface{}

type ControlPlaneProbes struct {
	// LivenessProbe specifies if the liveness probe for the container should be
	// enabled
	LivenessProbe *EnableSwitch `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// ReadinessProbe specifies if the readiness probe for the container should be
	// enabled
	ReadinessProbe *EnableSwitch `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// StartupProbe specifies if the startup probe for the container should be enabled
	StartupProbe *EnableSwitch `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`
}

type ControlPlaneProxy struct {
	// BindAddress under which vCluster will expose the proxy.
	BindAddress *string `json:"bindAddress,omitempty" yaml:"bindAddress,omitempty" mapstructure:"bindAddress,omitempty"`

	// ExtraSANs are extra hostnames to sign the vCluster proxy certificate for.
	ExtraSANs []string `json:"extraSANs,omitempty" yaml:"extraSANs,omitempty" mapstructure:"extraSANs,omitempty"`

	// Port under which vCluster will expose the proxy. Changing port is currently not
	// supported.
	Port *int `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
}

type ControlPlaneScheduling struct {
	// Affinity is the affinity to apply to the pod.
	Affinity ControlPlaneSchedulingAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// NodeSelector is the node selector to apply to the pod.
	NodeSelector ControlPlaneSchedulingNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// PodManagementPolicy is the statefulSet pod management policy.
	PodManagementPolicy *string `json:"podManagementPolicy,omitempty" yaml:"podManagementPolicy,omitempty" mapstructure:"podManagementPolicy,omitempty"`

	// PriorityClassName is the priority class name for the the pod.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// Tolerations are the tolerations to apply to the pod.
	Tolerations []ControlPlaneSchedulingTolerationsElem `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// TopologySpreadConstraints are the topology spread constraints for the pod.
	TopologySpreadConstraints []interface{} `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`
}

// Affinity is the affinity to apply to the pod.
type ControlPlaneSchedulingAffinity map[string]interface{}

// NodeSelector is the node selector to apply to the pod.
type ControlPlaneSchedulingNodeSelector map[string]interface{}

type ControlPlaneSchedulingTolerationsElem map[string]interface{}

type ControlPlaneSecurity struct {
	// ContainerSecurityContext specifies security context options on the container
	// level.
	ContainerSecurityContext ControlPlaneSecurityContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// PodSecurityContext specifies security context options on the pod level.
	PodSecurityContext ControlPlaneSecurityPodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty" mapstructure:"podSecurityContext,omitempty"`
}

// ContainerSecurityContext specifies security context options on the container
// level.
type ControlPlaneSecurityContainerSecurityContext map[string]interface{}

// PodSecurityContext specifies security context options on the pod level.
type ControlPlaneSecurityPodSecurityContext map[string]interface{}

type ControlPlaneService struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the control plane service should be enabled
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// HTTPSNodePort is the node port where https is exposed. Defaults to 0.
	HttpsNodePort *int `json:"httpsNodePort,omitempty" yaml:"httpsNodePort,omitempty" mapstructure:"httpsNodePort,omitempty"`

	// KubeletNodePort is the node port where the fake kubelet is exposed. Defaults to
	// 0.
	KubeletNodePort *int `json:"kubeletNodePort,omitempty" yaml:"kubeletNodePort,omitempty" mapstructure:"kubeletNodePort,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneServiceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Spec allows you to configure extra service options.
	Spec ControlPlaneServiceSpec `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`
}

type ControlPlaneServiceAccount struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneServiceAccountAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled specifies if the service account should get deployed.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ImagePullSecrets defines extra image pull secrets for the service account.
	ImagePullSecrets []ImagePullSecretName `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty" mapstructure:"imagePullSecrets,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneServiceAccountLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Name specifies what name to use for the service account.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneServiceAccountAnnotations map[string]string

// Labels are extra labels for this resource.
type ControlPlaneServiceAccountLabels map[string]string

// Annotations are extra annotations for this resource.
type ControlPlaneServiceAnnotations map[string]string

// Labels are extra labels for this resource.
type ControlPlaneServiceLabels map[string]string

// Spec allows you to configure extra service options.
type ControlPlaneServiceSpec map[string]interface{}

type ControlPlaneStatefulSet struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneStatefulSetAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Args allows you to override the main arguments.
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Command allows you to override the main command.
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Specifies the DNS parameters of a pod.
	DnsConfig *PodDNSConfig `json:"dnsConfig,omitempty" yaml:"dnsConfig,omitempty" mapstructure:"dnsConfig,omitempty"`

	// Set DNS policy for the pod.
	DnsPolicy *string `json:"dnsPolicy,omitempty" yaml:"dnsPolicy,omitempty" mapstructure:"dnsPolicy,omitempty"`

	// EnableServiceLinks for the StatefulSet pod
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// Env are additional environment variables for the statefulSet container.
	Env []ControlPlaneStatefulSetEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// HighAvailability holds options related to high availability.
	HighAvailability *ControlPlaneHighAvailability `json:"highAvailability,omitempty" yaml:"highAvailability,omitempty" mapstructure:"highAvailability,omitempty"`

	// Image is the image for the controlPlane statefulSet container
	Image *StatefulSetImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the policy how to pull the image.
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneStatefulSetLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Persistence defines options around persistence for the statefulSet.
	Persistence *ControlPlanePersistence `json:"persistence,omitempty" yaml:"persistence,omitempty" mapstructure:"persistence,omitempty"`

	// Additional labels or annotations for the statefulSet pods.
	Pods *LabelsAndAnnotations `json:"pods,omitempty" yaml:"pods,omitempty" mapstructure:"pods,omitempty"`

	// Probes enables or disables the main container probes.
	Probes *ControlPlaneProbes `json:"probes,omitempty" yaml:"probes,omitempty" mapstructure:"probes,omitempty"`

	// Resources are the resource requests and limits for the statefulSet container.
	Resources *Resources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Scheduling holds options related to scheduling.
	Scheduling *ControlPlaneScheduling `json:"scheduling,omitempty" yaml:"scheduling,omitempty" mapstructure:"scheduling,omitempty"`

	// Security defines pod or container security context.
	Security *ControlPlaneSecurity `json:"security,omitempty" yaml:"security,omitempty" mapstructure:"security,omitempty"`

	// WorkingDir specifies in what folder the main process should get started.
	WorkingDir *string `json:"workingDir,omitempty" yaml:"workingDir,omitempty" mapstructure:"workingDir,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneStatefulSetAnnotations map[string]string

type ControlPlaneStatefulSetEnvElem map[string]interface{}

// Labels are extra labels for this resource.
type ControlPlaneStatefulSetLabels map[string]string

type ControlPlaneWorkloadServiceAccount struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneWorkloadServiceAccountAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled specifies if the service account for the workloads should get deployed.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ImagePullSecrets defines extra image pull secrets for the workload service
	// account.
	ImagePullSecrets []ImagePullSecretName `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty" mapstructure:"imagePullSecrets,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneWorkloadServiceAccountLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Name specifies what name to use for the service account for the virtual cluster
	// workloads.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneWorkloadServiceAccountAnnotations map[string]string

// Labels are extra labels for this resource.
type ControlPlaneWorkloadServiceAccountLabels map[string]string

type CoreDNS struct {
	// Deployment holds extra options for the coredns deployment deployed within the
	// virtual cluster
	Deployment *CoreDNSDeployment `json:"deployment,omitempty" yaml:"deployment,omitempty" mapstructure:"deployment,omitempty"`

	// Embedded defines if vCluster will start the embedded coredns service within the
	// control-plane and not as a separate deployment. This is a PRO feature.
	Embedded *bool `json:"embedded,omitempty" yaml:"embedded,omitempty" mapstructure:"embedded,omitempty"`

	// Enabled defines if coredns is enabled
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// OverwriteConfig can be used to overwrite the coredns config
	OverwriteConfig *string `json:"overwriteConfig,omitempty" yaml:"overwriteConfig,omitempty" mapstructure:"overwriteConfig,omitempty"`

	// OverwriteManifests can be used to overwrite the coredns manifests used to
	// deploy coredns
	OverwriteManifests *string `json:"overwriteManifests,omitempty" yaml:"overwriteManifests,omitempty" mapstructure:"overwriteManifests,omitempty"`

	// PriorityClassName specifies the priority class name for the CoreDNS pods.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// Service holds extra options for the coredns service deployed within the virtual
	// cluster
	Service *CoreDNSService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

type CoreDNSDeployment struct {
	// Affinity is the affinity to apply to the pod.
	Affinity CoreDNSDeploymentAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// Annotations are extra annotations for this resource.
	Annotations CoreDNSDeploymentAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Image is the coredns image to use
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Labels are extra labels for this resource.
	Labels CoreDNSDeploymentLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// NodeSelector is the node selector to use for coredns.
	NodeSelector CoreDNSDeploymentNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// Pods is additional metadata for the coredns pods.
	Pods *LabelsAndAnnotations `json:"pods,omitempty" yaml:"pods,omitempty" mapstructure:"pods,omitempty"`

	// Replicas is the amount of coredns pods to run.
	Replicas *int `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`

	// Resources are the desired resources for coredns.
	Resources *Resources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Tolerations are the tolerations to apply to the pod.
	Tolerations []CoreDNSDeploymentTolerationsElem `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// TopologySpreadConstraints are the topology spread constraints for the CoreDNS
	// pod.
	TopologySpreadConstraints []interface{} `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`
}

// Affinity is the affinity to apply to the pod.
type CoreDNSDeploymentAffinity map[string]interface{}

// Annotations are extra annotations for this resource.
type CoreDNSDeploymentAnnotations map[string]string

// Labels are extra labels for this resource.
type CoreDNSDeploymentLabels map[string]string

// NodeSelector is the node selector to use for coredns.
type CoreDNSDeploymentNodeSelector map[string]string

type CoreDNSDeploymentTolerationsElem map[string]interface{}

type CoreDNSService struct {
	// Annotations are extra annotations for this resource.
	Annotations CoreDNSServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels are extra labels for this resource.
	Labels CoreDNSServiceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Spec holds extra options for the coredns service
	Spec CoreDNSServiceSpec `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`
}

// Annotations are extra annotations for this resource.
type CoreDNSServiceAnnotations map[string]string

// Labels are extra labels for this resource.
type CoreDNSServiceLabels map[string]string

// Spec holds extra options for the coredns service
type CoreDNSServiceSpec map[string]interface{}

type Database struct {
	// Embedded defines that an embedded database (sqlite) should be used as the
	// backend for the virtual cluster
	Embedded *DatabaseKine `json:"embedded,omitempty" yaml:"embedded,omitempty" mapstructure:"embedded,omitempty"`

	// External defines that an external database should be used as the backend for
	// the virtual cluster
	External *ExternalDatabaseKine `json:"external,omitempty" yaml:"external,omitempty" mapstructure:"external,omitempty"`
}

type DatabaseKine struct {
	// CaFile is the ca file to use for the database. This is optional.
	CaFile *string `json:"caFile,omitempty" yaml:"caFile,omitempty" mapstructure:"caFile,omitempty"`

	// CertFile is the cert file to use for the database. This is optional.
	CertFile *string `json:"certFile,omitempty" yaml:"certFile,omitempty" mapstructure:"certFile,omitempty"`

	// DataSource is the kine dataSource to use for the database. This depends on the
	// database format.
	// This is optional for the embedded database. Examples:
	// * mysql: mysql://username:password@tcp(hostname:3306)/k3s
	// * postgres: postgres://username:password@hostname:5432/k3s
	DataSource *string `json:"dataSource,omitempty" yaml:"dataSource,omitempty" mapstructure:"dataSource,omitempty"`

	// Enabled defines if the database should be used.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// KeyFile is the key file to use for the database. This is optional.
	KeyFile *string `json:"keyFile,omitempty" yaml:"keyFile,omitempty" mapstructure:"keyFile,omitempty"`
}

type DenyRule struct {
	// ExcludedUsers describe a list of users for which the checks will be skipped.
	// Impersonation attempts on these users will still be subjected to the checks.
	ExcludedUsers []string `json:"excludedUsers,omitempty" yaml:"excludedUsers,omitempty" mapstructure:"excludedUsers,omitempty"`

	// The name of the check.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace describe a list of namespaces that will be affected by the check.
	// An empty list means that all namespaces will be affected.
	// In case of ClusterScoped rules, only the Namespace resource is affected.
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// Rules describes on which verbs and on what resources/subresources the webhook
	// is enforced.
	// The webhook is enforced if it matches any Rule.
	// The version of the request must match the rule version exactly. Equivalent
	// matching is not supported.
	Rules []RuleWithVerbs `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`
}

type Distro struct {
	// K0S holds k0s relevant configuration.
	K0S *DistroK0S `json:"k0s,omitempty" yaml:"k0s,omitempty" mapstructure:"k0s,omitempty"`

	// K3S holds K3s relevant configuration.
	K3S *DistroK3S `json:"k3s,omitempty" yaml:"k3s,omitempty" mapstructure:"k3s,omitempty"`

	// K8S holds K8s relevant configuration.
	K8S *DistroK8S `json:"k8s,omitempty" yaml:"k8s,omitempty" mapstructure:"k8s,omitempty"`
}

type DistroContainer struct {
	// Command is the command to start the distro binary. This will override the
	// existing command.
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// ExtraArgs are additional arguments to pass to the distro binary.
	ExtraArgs []string `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// Image is the distro image
	Image *Image `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy for the distro image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`
}

type DistroContainerEnabled struct {
	// Command is the command to start the distro binary. This will override the
	// existing command.
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Enabled signals this container should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ExtraArgs are additional arguments to pass to the distro binary.
	ExtraArgs []string `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// Image is the distro image
	Image *Image `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy for the distro image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`
}

type DistroK0S struct {
	// Command is the command to start the distro binary. This will override the
	// existing command.
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Config allows you to override the k0s config passed to the k0s binary.
	Config *string `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Enabled specifies if the k0s distro should be enabled. Only one distro can be
	// enabled at the same time.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Env are extra environment variables to use for the main container and NOT the
	// init container.
	Env []DistroK0SEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// ExtraArgs are additional arguments to pass to the distro binary.
	ExtraArgs []string `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// Image is the distro image
	Image *Image `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy for the distro image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Resources for the distro init container
	Resources DistroK0SResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Security options can be used for the distro init container
	SecurityContext DistroK0SSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`
}

type DistroK0SEnvElem map[string]interface{}

// Resources for the distro init container
type DistroK0SResources map[string]interface{}

// Security options can be used for the distro init container
type DistroK0SSecurityContext map[string]interface{}

type DistroK3S struct {
	// Command is the command to start the distro binary. This will override the
	// existing command.
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Enabled specifies if the K3s distro should be enabled. Only one distro can be
	// enabled at the same time.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Env are extra environment variables to use for the main container and NOT the
	// init container.
	Env []DistroK3SEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// ExtraArgs are additional arguments to pass to the distro binary.
	ExtraArgs []string `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// Image is the distro image
	Image *Image `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy for the distro image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Resources for the distro init container
	Resources DistroK3SResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Security options can be used for the distro init container
	SecurityContext DistroK3SSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// Token is the K3s token to use. If empty, vCluster will choose one.
	Token *string `json:"token,omitempty" yaml:"token,omitempty" mapstructure:"token,omitempty"`
}

type DistroK3SEnvElem map[string]interface{}

// Resources for the distro init container
type DistroK3SResources map[string]interface{}

// Security options can be used for the distro init container
type DistroK3SSecurityContext map[string]interface{}

type DistroK8S struct {
	// APIServer holds configuration specific to starting the api server.
	ApiServer *DistroContainerEnabled `json:"apiServer,omitempty" yaml:"apiServer,omitempty" mapstructure:"apiServer,omitempty"`

	// ControllerManager holds configuration specific to starting the controller
	// manager.
	ControllerManager *DistroContainerEnabled `json:"controllerManager,omitempty" yaml:"controllerManager,omitempty" mapstructure:"controllerManager,omitempty"`

	// Enabled specifies if the K8s distro should be enabled. Only one distro can be
	// enabled at the same time.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Env are extra environment variables to use for the main container and NOT the
	// init container.
	Env []DistroK8SEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// Resources for the distro init container
	Resources DistroK8SResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Scheduler holds configuration specific to starting the scheduler. Enable this
	// via controlPlane.advanced.virtualScheduler.enabled
	Scheduler *DistroContainer `json:"scheduler,omitempty" yaml:"scheduler,omitempty" mapstructure:"scheduler,omitempty"`

	// Security options can be used for the distro init container
	SecurityContext DistroK8SSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// Version specifies k8s components (scheduler, kube-controller-manager &
	// apiserver) version.
	// It is a shortcut for controlPlane.distro.k8s.apiServer.image.tag,
	// controlPlane.distro.k8s.controllerManager.image.tag and
	// controlPlane.distro.k8s.scheduler.image.tag
	// If e.g. controlPlane.distro.k8s.version is set to v1.30.1 and
	// controlPlane.distro.k8s.scheduler.image.tag
	// (or controlPlane.distro.k8s.controllerManager.image.tag or
	// controlPlane.distro.k8s.apiServer.image.tag)
	// is set to v1.31.0,
	// value from controlPlane.distro.k8s.(controlPlane-component).image.tag will be
	// used
	// (where controlPlane-component is apiServer, controllerManager and scheduler).
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type DistroK8SEnvElem map[string]interface{}

// Resources for the distro init container
type DistroK8SResources map[string]interface{}

// Security options can be used for the distro init container
type DistroK8SSecurityContext map[string]interface{}

type EnableAutoSwitchWithPatches struct {
	// Enabled defines if this option should be enabled.
	Enabled interface{} `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Patches patch the resource according to the provided specification.
	Patches []TranslatePatch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`
}

type EnableSwitch struct {
	// Enabled defines if this option should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type EnableSwitchWithPatches struct {
	// Enabled defines if this option should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Patches patch the resource according to the provided specification.
	Patches []TranslatePatch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`
}

type EnableSwitchWithResourcesMappings struct {
	// Enabled defines if this option should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Mappings for Namespace and Object
	Mappings *FromHostMappings `json:"mappings,omitempty" yaml:"mappings,omitempty" mapstructure:"mappings,omitempty"`

	// Patches patch the resource according to the provided specification.
	Patches []TranslatePatch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`
}

type Etcd struct {
	// Deploy defines to use an external etcd that is deployed by the helm chart
	Deploy *EtcdDeploy `json:"deploy,omitempty" yaml:"deploy,omitempty" mapstructure:"deploy,omitempty"`

	// Embedded defines to use embedded etcd as a storage backend for the virtual
	// cluster
	Embedded *EtcdEmbedded `json:"embedded,omitempty" yaml:"embedded,omitempty" mapstructure:"embedded,omitempty"`
}

type EtcdDeploy struct {
	// Enabled defines that an external etcd should be deployed.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// HeadlessService holds options for the external etcd headless service.
	HeadlessService *EtcdDeployHeadlessService `json:"headlessService,omitempty" yaml:"headlessService,omitempty" mapstructure:"headlessService,omitempty"`

	// Service holds options for the external etcd service.
	Service *EtcdDeployService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// StatefulSet holds options for the external etcd statefulSet.
	StatefulSet *EtcdDeployStatefulSet `json:"statefulSet,omitempty" yaml:"statefulSet,omitempty" mapstructure:"statefulSet,omitempty"`
}

type EtcdDeployHeadlessService struct {
	// Annotations are extra annotations for the external etcd headless service
	Annotations EtcdDeployHeadlessServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`
}

// Annotations are extra annotations for the external etcd headless service
type EtcdDeployHeadlessServiceAnnotations map[string]string

type EtcdDeployService struct {
	// Annotations are extra annotations for the external etcd service
	Annotations EtcdDeployServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the etcd service should be deployed
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

// Annotations are extra annotations for the external etcd service
type EtcdDeployServiceAnnotations map[string]string

type EtcdDeployStatefulSet struct {
	// Annotations are extra annotations for this resource.
	Annotations EtcdDeployStatefulSetAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// EnableServiceLinks for the StatefulSet pod
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// Enabled defines if the statefulSet should be deployed
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Env are extra environment variables
	Env []EtcdDeployStatefulSetEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// ExtraArgs are appended to the etcd command.
	ExtraArgs []string `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// HighAvailability are high availability options
	HighAvailability *ExternalEtcdHighAvailability `json:"highAvailability,omitempty" yaml:"highAvailability,omitempty" mapstructure:"highAvailability,omitempty"`

	// Image is the image to use for the external etcd statefulSet
	Image *Image `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy for the external etcd image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Labels are extra labels for this resource.
	Labels EtcdDeployStatefulSetLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Persistence options for the etcd pods.
	Persistence *ExternalEtcdPersistence `json:"persistence,omitempty" yaml:"persistence,omitempty" mapstructure:"persistence,omitempty"`

	// Pods defines extra metadata for the etcd pods.
	Pods *LabelsAndAnnotations `json:"pods,omitempty" yaml:"pods,omitempty" mapstructure:"pods,omitempty"`

	// Resources the etcd can consume
	Resources *Resources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Scheduling options for the etcd pods.
	Scheduling *ControlPlaneScheduling `json:"scheduling,omitempty" yaml:"scheduling,omitempty" mapstructure:"scheduling,omitempty"`

	// Security options for the etcd pods.
	Security *ControlPlaneSecurity `json:"security,omitempty" yaml:"security,omitempty" mapstructure:"security,omitempty"`
}

// Annotations are extra annotations for this resource.
type EtcdDeployStatefulSetAnnotations map[string]string

type EtcdDeployStatefulSetEnvElem map[string]interface{}

// Labels are extra labels for this resource.
type EtcdDeployStatefulSetLabels map[string]string

type EtcdEmbedded struct {
	// Enabled defines if the embedded etcd should be used.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// MigrateFromDeployedEtcd signals that vCluster should migrate from the deployed
	// external etcd to embedded etcd.
	MigrateFromDeployedEtcd *bool `json:"migrateFromDeployedEtcd,omitempty" yaml:"migrateFromDeployedEtcd,omitempty" mapstructure:"migrateFromDeployedEtcd,omitempty"`
}

type Experimental struct {
	// DenyProxyRequests denies certain requests in the vCluster proxy.
	DenyProxyRequests []DenyRule `json:"denyProxyRequests,omitempty" yaml:"denyProxyRequests,omitempty" mapstructure:"denyProxyRequests,omitempty"`

	// Deploy allows you to configure manifests and Helm charts to deploy within the
	// host or virtual cluster.
	Deploy *ExperimentalDeploy `json:"deploy,omitempty" yaml:"deploy,omitempty" mapstructure:"deploy,omitempty"`

	// GenericSync holds options to generically sync resources from virtual cluster to
	// host.
	GenericSync *ExperimentalGenericSync `json:"genericSync,omitempty" yaml:"genericSync,omitempty" mapstructure:"genericSync,omitempty"`

	// IsolatedControlPlane is a feature to run the vCluster control plane in a
	// different Kubernetes cluster than the workloads themselves.
	IsolatedControlPlane *ExperimentalIsolatedControlPlane `json:"isolatedControlPlane,omitempty" yaml:"isolatedControlPlane,omitempty" mapstructure:"isolatedControlPlane,omitempty"`

	// MultiNamespaceMode tells virtual cluster to sync to multiple namespaces instead
	// of a single one. This will map each virtual cluster namespace to a single
	// namespace in the host cluster.
	MultiNamespaceMode *ExperimentalMultiNamespaceMode `json:"multiNamespaceMode,omitempty" yaml:"multiNamespaceMode,omitempty" mapstructure:"multiNamespaceMode,omitempty"`

	// ReuseNamespace allows reusing the same namespace to create multiple vClusters.
	// This flag is deprecated, as this scenario will be removed entirely in upcoming
	// releases.
	ReuseNamespace *bool `json:"reuseNamespace,omitempty" yaml:"reuseNamespace,omitempty" mapstructure:"reuseNamespace,omitempty"`

	// SyncSettings are advanced settings for the syncer controller.
	SyncSettings *ExperimentalSyncSettings `json:"syncSettings,omitempty" yaml:"syncSettings,omitempty" mapstructure:"syncSettings,omitempty"`

	// VirtualClusterKubeConfig allows you to override distro specifics and specify
	// where vCluster will find the required certificates and vCluster config.
	VirtualClusterKubeConfig *VirtualClusterKubeConfig `json:"virtualClusterKubeConfig,omitempty" yaml:"virtualClusterKubeConfig,omitempty" mapstructure:"virtualClusterKubeConfig,omitempty"`
}

type ExperimentalDeploy struct {
	// Host defines what manifests to deploy into the host cluster
	Host *ExperimentalDeployHost `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`

	// VCluster defines what manifests and charts to deploy into the vCluster
	Vcluster *ExperimentalDeployVCluster `json:"vcluster,omitempty" yaml:"vcluster,omitempty" mapstructure:"vcluster,omitempty"`
}

type ExperimentalDeployHelm struct {
	// Bundle allows to compress the Helm chart and specify this instead of an online
	// chart
	Bundle *string `json:"bundle,omitempty" yaml:"bundle,omitempty" mapstructure:"bundle,omitempty"`

	// Chart defines what chart should get deployed.
	Chart *ExperimentalDeployHelmChart `json:"chart,omitempty" yaml:"chart,omitempty" mapstructure:"chart,omitempty"`

	// Release defines what release should get deployed.
	Release *ExperimentalDeployHelmRelease `json:"release,omitempty" yaml:"release,omitempty" mapstructure:"release,omitempty"`

	// Timeout defines the timeout for Helm
	Timeout *string `json:"timeout,omitempty" yaml:"timeout,omitempty" mapstructure:"timeout,omitempty"`

	// Values defines what values should get used.
	Values *string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

type ExperimentalDeployHelmChart struct {
	// Insecure corresponds to the JSON schema field "insecure".
	Insecure *bool `json:"insecure,omitempty" yaml:"insecure,omitempty" mapstructure:"insecure,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Password corresponds to the JSON schema field "password".
	Password *string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// Repo corresponds to the JSON schema field "repo".
	Repo *string `json:"repo,omitempty" yaml:"repo,omitempty" mapstructure:"repo,omitempty"`

	// Username corresponds to the JSON schema field "username".
	Username *string `json:"username,omitempty" yaml:"username,omitempty" mapstructure:"username,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type ExperimentalDeployHelmRelease struct {
	// Name of the release
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace of the release
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`
}

type ExperimentalDeployHost struct {
	// Manifests are raw Kubernetes manifests that should get applied within the host
	// cluster.
	Manifests *string `json:"manifests,omitempty" yaml:"manifests,omitempty" mapstructure:"manifests,omitempty"`

	// ManifestsTemplate is a Kubernetes manifest template that will be rendered with
	// vCluster values before applying it within the host cluster.
	ManifestsTemplate *string `json:"manifestsTemplate,omitempty" yaml:"manifestsTemplate,omitempty" mapstructure:"manifestsTemplate,omitempty"`
}

type ExperimentalDeployVCluster struct {
	// Helm are Helm charts that should get deployed into the virtual cluster
	Helm []ExperimentalDeployHelm `json:"helm,omitempty" yaml:"helm,omitempty" mapstructure:"helm,omitempty"`

	// Manifests are raw Kubernetes manifests that should get applied within the
	// virtual cluster.
	Manifests *string `json:"manifests,omitempty" yaml:"manifests,omitempty" mapstructure:"manifests,omitempty"`

	// ManifestsTemplate is a Kubernetes manifest template that will be rendered with
	// vCluster values before applying it within the virtual cluster.
	ManifestsTemplate *string `json:"manifestsTemplate,omitempty" yaml:"manifestsTemplate,omitempty" mapstructure:"manifestsTemplate,omitempty"`
}

type ExperimentalGenericSync struct {
	// ClusterRole corresponds to the JSON schema field "clusterRole".
	ClusterRole *ExperimentalGenericSyncExtraRules `json:"clusterRole,omitempty" yaml:"clusterRole,omitempty" mapstructure:"clusterRole,omitempty"`

	// Exports syncs a resource from the virtual cluster to the host
	Export []Export `json:"export,omitempty" yaml:"export,omitempty" mapstructure:"export,omitempty"`

	// Hooks are hooks that can be used to inject custom patches before syncing
	Hooks *Hooks `json:"hooks,omitempty" yaml:"hooks,omitempty" mapstructure:"hooks,omitempty"`

	// Imports syncs a resource from the host cluster to virtual cluster
	Import []Import `json:"import,omitempty" yaml:"import,omitempty" mapstructure:"import,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *ExperimentalGenericSyncExtraRules `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Version is the config version
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type ExperimentalGenericSyncExtraRules struct {
	// ExtraRules corresponds to the JSON schema field "extraRules".
	ExtraRules []interface{} `json:"extraRules,omitempty" yaml:"extraRules,omitempty" mapstructure:"extraRules,omitempty"`
}

type ExperimentalIsolatedControlPlane struct {
	// Enabled specifies if the isolated control plane feature should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Headless states that Helm should deploy the vCluster in headless mode for the
	// isolated control plane.
	Headless *bool `json:"headless,omitempty" yaml:"headless,omitempty" mapstructure:"headless,omitempty"`

	// KubeConfig is the path where to find the remote workload cluster kubeconfig.
	KubeConfig *string `json:"kubeConfig,omitempty" yaml:"kubeConfig,omitempty" mapstructure:"kubeConfig,omitempty"`

	// Namespace is the namespace where to sync the workloads into.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Service is the vCluster service in the remote cluster.
	Service *string `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

type ExperimentalMultiNamespaceMode struct {
	// Enabled specifies if multi namespace mode should get enabled
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// NamespaceLabels are extra labels that will be added by vCluster to each created
	// namespace.
	NamespaceLabels ExperimentalMultiNamespaceModeNamespaceLabels `json:"namespaceLabels,omitempty" yaml:"namespaceLabels,omitempty" mapstructure:"namespaceLabels,omitempty"`
}

// NamespaceLabels are extra labels that will be added by vCluster to each created
// namespace.
type ExperimentalMultiNamespaceModeNamespaceLabels map[string]string

type ExperimentalSyncSettings struct {
	// DisableSync will not sync any resources and disable most control plane
	// functionality.
	DisableSync *bool `json:"disableSync,omitempty" yaml:"disableSync,omitempty" mapstructure:"disableSync,omitempty"`

	// HostMetricsBindAddress is the bind address for the local manager
	HostMetricsBindAddress *string `json:"hostMetricsBindAddress,omitempty" yaml:"hostMetricsBindAddress,omitempty" mapstructure:"hostMetricsBindAddress,omitempty"`

	// RewriteKubernetesService will rewrite the Kubernetes service to point to the
	// vCluster service if disableSync is enabled
	RewriteKubernetesService *bool `json:"rewriteKubernetesService,omitempty" yaml:"rewriteKubernetesService,omitempty" mapstructure:"rewriteKubernetesService,omitempty"`

	// SetOwner specifies if vCluster should set an owner reference on the synced
	// objects to the vCluster service. This allows for easy garbage collection.
	SetOwner *bool `json:"setOwner,omitempty" yaml:"setOwner,omitempty" mapstructure:"setOwner,omitempty"`

	// TargetNamespace is the namespace where the workloads should get synced to.
	TargetNamespace *string `json:"targetNamespace,omitempty" yaml:"targetNamespace,omitempty" mapstructure:"targetNamespace,omitempty"`

	// VirtualMetricsBindAddress is the bind address for the virtual manager
	VirtualMetricsBindAddress *string `json:"virtualMetricsBindAddress,omitempty" yaml:"virtualMetricsBindAddress,omitempty" mapstructure:"virtualMetricsBindAddress,omitempty"`
}

type Export struct {
	// APIVersion of the object to sync
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" mapstructure:"apiVersion,omitempty"`

	// Kind of the object to sync
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// Patches are the patches to apply on the virtual cluster objects
	// when syncing them from the host cluster
	Patches []Patch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// ReplaceWhenInvalid determines if the controller should try to recreate the
	// object
	// if there is a problem applying
	ReplaceOnConflict *bool `json:"replaceOnConflict,omitempty" yaml:"replaceOnConflict,omitempty" mapstructure:"replaceOnConflict,omitempty"`

	// ReversePatches are the patches to apply to host cluster objects
	// after it has been synced to the virtual cluster
	ReversePatches []Patch `json:"reversePatches,omitempty" yaml:"reversePatches,omitempty" mapstructure:"reversePatches,omitempty"`

	// Selector is a label selector to select the synced objects in the virtual
	// cluster.
	// If empty, all objects will be synced.
	Selector *Selector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`
}

// ExportKubeConfig describes how vCluster should export the vCluster kubeconfig.
type ExportKubeConfig struct {
	// AdditionalSecrets specifies the additional host cluster secrets in which
	// vCluster will store the
	// generated virtual cluster kubeconfigs.
	AdditionalSecrets []ExportKubeConfigAdditionalSecretReference `json:"additionalSecrets,omitempty" yaml:"additionalSecrets,omitempty" mapstructure:"additionalSecrets,omitempty"`

	// Context is the name of the context within the generated kubeconfig to use.
	Context *string `json:"context,omitempty" yaml:"context,omitempty" mapstructure:"context,omitempty"`

	// If tls should get skipped for the server
	Insecure *bool `json:"insecure,omitempty" yaml:"insecure,omitempty" mapstructure:"insecure,omitempty"`

	// Declare in which host cluster secret vCluster should store the generated
	// virtual cluster kubeconfig.
	// If this is not defined, vCluster will create it with `vc-NAME`. If you specify
	// another name,
	// vCluster creates the config in this other secret.
	//
	// Deprecated: Use AdditionalSecrets instead.
	Secret *ExportKubeConfigSecretReference `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`

	// Override the default https://localhost:8443 and specify a custom hostname for
	// the generated kubeconfig.
	Server *string `json:"server,omitempty" yaml:"server,omitempty" mapstructure:"server,omitempty"`

	// ServiceAccount can be used to generate a service account token instead of the
	// default certificates.
	ServiceAccount *ExportKubeConfigServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`
}

// ExportKubeConfigAdditionalSecretReference defines the additional host cluster
// secret in which vCluster stores the generated virtual cluster kubeconfigs.
type ExportKubeConfigAdditionalSecretReference struct {
	// Context is the name of the context within the generated kubeconfig to use.
	Context *string `json:"context,omitempty" yaml:"context,omitempty" mapstructure:"context,omitempty"`

	// If tls should get skipped for the server
	Insecure *bool `json:"insecure,omitempty" yaml:"insecure,omitempty" mapstructure:"insecure,omitempty"`

	// Name is the name of the secret where the kubeconfig is stored.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace where vCluster stores the kubeconfig secret. If this is not equal to
	// the namespace
	// where you deployed vCluster, you need to make sure vCluster has access to this
	// other namespace.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Override the default https://localhost:8443 and specify a custom hostname for
	// the generated kubeconfig.
	Server *string `json:"server,omitempty" yaml:"server,omitempty" mapstructure:"server,omitempty"`

	// ServiceAccount can be used to generate a service account token instead of the
	// default certificates.
	ServiceAccount *ExportKubeConfigServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`
}

// Declare in which host cluster secret vCluster should store the generated virtual
// cluster kubeconfig.
type ExportKubeConfigSecretReference struct {
	// Name is the name of the secret where the kubeconfig should get stored.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace where vCluster should store the kubeconfig secret. If this is not
	// equal to the namespace
	// where you deployed vCluster, you need to make sure vCluster has access to this
	// other namespace.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`
}

type ExportKubeConfigServiceAccount struct {
	// ClusterRole to assign to the service account.
	ClusterRole *string `json:"clusterRole,omitempty" yaml:"clusterRole,omitempty" mapstructure:"clusterRole,omitempty"`

	// Name of the service account to be used to generate a service account token
	// instead of the default certificates.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace of the service account to be used to generate a service account token
	// instead of the default certificates.
	// If omitted, will use the kube-system namespace.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`
}

// ExternalConfig holds external configuration
type ExternalConfig struct {
	// platform holds platform configuration
	Platform *PlatformConfig `json:"platform,omitempty" yaml:"platform,omitempty" mapstructure:"platform,omitempty"`
}

type ExternalDatabaseKine struct {
	// CaFile is the ca file to use for the database. This is optional.
	CaFile *string `json:"caFile,omitempty" yaml:"caFile,omitempty" mapstructure:"caFile,omitempty"`

	// CertFile is the cert file to use for the database. This is optional.
	CertFile *string `json:"certFile,omitempty" yaml:"certFile,omitempty" mapstructure:"certFile,omitempty"`

	// Connector specifies a secret located in a connected vCluster Platform that
	// contains database server connection information
	// to be used by Platform to create a database and database user for the vCluster.
	// and non-privileged user. A kine endpoint should be created using the database
	// and user on Platform registration.
	// This is optional.
	Connector *string `json:"connector,omitempty" yaml:"connector,omitempty" mapstructure:"connector,omitempty"`

	// DataSource is the kine dataSource to use for the database. This depends on the
	// database format.
	// This is optional for the embedded database. Examples:
	// * mysql: mysql://username:password@tcp(hostname:3306)/k3s
	// * postgres: postgres://username:password@hostname:5432/k3s
	DataSource *string `json:"dataSource,omitempty" yaml:"dataSource,omitempty" mapstructure:"dataSource,omitempty"`

	// Enabled defines if the database should be used.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// KeyFile is the key file to use for the database. This is optional.
	KeyFile *string `json:"keyFile,omitempty" yaml:"keyFile,omitempty" mapstructure:"keyFile,omitempty"`
}

type ExternalEtcdHighAvailability struct {
	// Replicas are the amount of pods to use.
	Replicas *int `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`
}

type ExternalEtcdPersistence struct {
	// AddVolumeMounts defines extra volume mounts for the container
	AddVolumeMounts []VolumeMount `json:"addVolumeMounts,omitempty" yaml:"addVolumeMounts,omitempty" mapstructure:"addVolumeMounts,omitempty"`

	// AddVolumes defines extra volumes for the pod
	AddVolumes []ExternalEtcdPersistenceAddVolumesElem `json:"addVolumes,omitempty" yaml:"addVolumes,omitempty" mapstructure:"addVolumes,omitempty"`

	// VolumeClaim can be used to configure the persistent volume claim.
	VolumeClaim *ExternalEtcdPersistenceVolumeClaim `json:"volumeClaim,omitempty" yaml:"volumeClaim,omitempty" mapstructure:"volumeClaim,omitempty"`

	// VolumeClaimTemplates defines the volumeClaimTemplates for the statefulSet
	VolumeClaimTemplates []ExternalEtcdPersistenceVolumeClaimTemplatesElem `json:"volumeClaimTemplates,omitempty" yaml:"volumeClaimTemplates,omitempty" mapstructure:"volumeClaimTemplates,omitempty"`
}

type ExternalEtcdPersistenceAddVolumesElem map[string]interface{}

type ExternalEtcdPersistenceVolumeClaim struct {
	// AccessModes are the persistent volume claim access modes.
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Enabled enables deploying a persistent volume claim.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// RetentionPolicy is the persistent volume claim retention policy.
	RetentionPolicy *string `json:"retentionPolicy,omitempty" yaml:"retentionPolicy,omitempty" mapstructure:"retentionPolicy,omitempty"`

	// Size is the persistent volume claim storage size.
	Size *string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// StorageClass is the persistent volume claim storage class.
	StorageClass *string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

type ExternalEtcdPersistenceVolumeClaimTemplatesElem map[string]interface{}

// ExternalSecrets reuses a host external secret operator and makes certain CRDs
// from it available inside the vCluster
type ExternalSecrets struct {
	// Enabled defines whether the external secret integration is enabled or not
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Sync defines the syncing behavior for the integration
	Sync *ExternalSecretsSync `json:"sync,omitempty" yaml:"sync,omitempty" mapstructure:"sync,omitempty"`

	// Webhook defines whether the host webhooks are reused or not
	Webhook *EnableSwitch `json:"webhook,omitempty" yaml:"webhook,omitempty" mapstructure:"webhook,omitempty"`
}

type ExternalSecretsSync struct {
	// ClusterStores defines whether to sync cluster stores or not
	ClusterStores *ClusterStoresSyncConfig `json:"clusterStores,omitempty" yaml:"clusterStores,omitempty" mapstructure:"clusterStores,omitempty"`

	// ExternalSecrets defines whether to sync external secrets or not
	ExternalSecrets *EnableSwitch `json:"externalSecrets,omitempty" yaml:"externalSecrets,omitempty" mapstructure:"externalSecrets,omitempty"`

	// Stores defines whether to sync stores or not
	Stores *EnableSwitch `json:"stores,omitempty" yaml:"stores,omitempty" mapstructure:"stores,omitempty"`
}

type FromHostMappings struct {
	// ByName is a map of host-object-namespace/host-object-name:
	// virtual-object-namespace/virtual-object-name.
	// There are several wildcards supported:
	// 1. To match all objects in host namespace and sync them to different namespace
	// in vCluster:
	// byName:
	//   "foo/*": "foo-in-virtual/*"
	// 2. To match specific object in the host namespace and sync it to the same
	// namespace with the same name:
	// byName:
	//   "foo/my-object": "foo/my-object"
	// 3. To match specific object in the host namespace and sync it to the same
	// namespace with different name:
	// byName:
	//   "foo/my-object": "foo/my-virtual-object"
	// 4. To match all objects in the vCluster host namespace and sync them to a
	// different namespace in vCluster:
	// byName:
	//   "": "my-virtual-namespace/*"
	// 5. To match specific objects in the vCluster host namespace and sync them to a
	// different namespace in vCluster:
	// byName:
	//   "/my-object": "my-virtual-namespace/my-object"
	ByName FromHostMappingsByName `json:"byName,omitempty" yaml:"byName,omitempty" mapstructure:"byName,omitempty"`
}

// ByName is a map of host-object-namespace/host-object-name:
// virtual-object-namespace/virtual-object-name.
// There are several wildcards supported:
// 1. To match all objects in host namespace and sync them to different namespace
// in vCluster:
// byName:
//
//	"foo/*": "foo-in-virtual/*"
//
// 2. To match specific object in the host namespace and sync it to the same
// namespace with the same name:
// byName:
//
//	"foo/my-object": "foo/my-object"
//
// 3. To match specific object in the host namespace and sync it to the same
// namespace with different name:
// byName:
//
//	"foo/my-object": "foo/my-virtual-object"
//
// 4. To match all objects in the vCluster host namespace and sync them to a
// different namespace in vCluster:
// byName:
//
//	"": "my-virtual-namespace/*"
//
// 5. To match specific objects in the vCluster host namespace and sync them to a
// different namespace in vCluster:
// byName:
//
//	"/my-object": "my-virtual-namespace/my-object"
type FromHostMappingsByName map[string]string

type Hook struct {
	// APIVersion of the object to sync
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" mapstructure:"apiVersion,omitempty"`

	// Kind of the object to sync
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Patches are the patches to apply on the object to be synced
	Patches []Patch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// Verbs are the verbs that the hook should mutate
	Verbs []string `json:"verbs,omitempty" yaml:"verbs,omitempty" mapstructure:"verbs,omitempty"`
}

type Hooks struct {
	// HostToVirtual is a hook that is executed before syncing from the host to the
	// virtual cluster
	HostToVirtual []Hook `json:"hostToVirtual,omitempty" yaml:"hostToVirtual,omitempty" mapstructure:"hostToVirtual,omitempty"`

	// VirtualToHost is a hook that is executed before syncing from the virtual to the
	// host cluster
	VirtualToHost []Hook `json:"virtualToHost,omitempty" yaml:"virtualToHost,omitempty" mapstructure:"virtualToHost,omitempty"`
}

type HostPathMapper struct {
	// Central specifies if the central host path mapper will be used
	Central *bool `json:"central,omitempty" yaml:"central,omitempty" mapstructure:"central,omitempty"`

	// Enabled specifies if the host path mapper will be used
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type IPBlock struct {
	// cidr is a string representing the IPBlock
	// Valid examples are "192.168.1.0/24" or "2001:db8::/64"
	Cidr *string `json:"cidr,omitempty" yaml:"cidr,omitempty" mapstructure:"cidr,omitempty"`

	// except is a slice of CIDRs that should not be included within an IPBlock
	// Valid examples are "192.168.1.0/24" or "2001:db8::/64"
	// Except values will be rejected if they are outside the cidr range
	// +optional
	Except []string `json:"except,omitempty" yaml:"except,omitempty" mapstructure:"except,omitempty"`
}

type Image struct {
	// Registry is the registry of the container image, e.g. my-registry.com or
	// ghcr.io. This setting can be globally
	// overridden via the controlPlane.advanced.defaultImageRegistry option. Empty
	// means docker hub.
	Registry *string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Repository is the repository of the container image, e.g. my-repo/my-image
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`

	// Tag is the tag of the container image, e.g. latest
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

type ImagePullSecretName struct {
	// Name of the image pull secret to use.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

type Import struct {
	// APIVersion of the object to sync
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" mapstructure:"apiVersion,omitempty"`

	// Kind of the object to sync
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// Patches are the patches to apply on the virtual cluster objects
	// when syncing them from the host cluster
	Patches []Patch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// ReplaceWhenInvalid determines if the controller should try to recreate the
	// object
	// if there is a problem applying
	ReplaceOnConflict *bool `json:"replaceOnConflict,omitempty" yaml:"replaceOnConflict,omitempty" mapstructure:"replaceOnConflict,omitempty"`

	// ReversePatches are the patches to apply to host cluster objects
	// after it has been synced to the virtual cluster
	ReversePatches []Patch `json:"reversePatches,omitempty" yaml:"reversePatches,omitempty" mapstructure:"reversePatches,omitempty"`
}

// Integrations holds config for vCluster integrations with other operators or
// tools running on the host cluster
type Integrations struct {
	// CertManager reuses a host cert-manager and makes its CRDs from it available
	// inside the vCluster.
	// - Certificates and Issuers will be synced from the virtual cluster to the host
	// cluster.
	// - ClusterIssuers will be synced from the host cluster to the virtual cluster.
	CertManager *CertManager `json:"certManager,omitempty" yaml:"certManager,omitempty" mapstructure:"certManager,omitempty"`

	// ExternalSecrets reuses a host external secret operator and makes certain CRDs
	// from it available inside the vCluster
	ExternalSecrets *ExternalSecrets `json:"externalSecrets,omitempty" yaml:"externalSecrets,omitempty" mapstructure:"externalSecrets,omitempty"`

	// KubeVirt reuses a host kubevirt and makes certain CRDs from it available inside
	// the vCluster
	KubeVirt *KubeVirt `json:"kubeVirt,omitempty" yaml:"kubeVirt,omitempty" mapstructure:"kubeVirt,omitempty"`

	// MetricsServer reuses the metrics server from the host cluster within the
	// vCluster.
	MetricsServer *MetricsServer `json:"metricsServer,omitempty" yaml:"metricsServer,omitempty" mapstructure:"metricsServer,omitempty"`
}

// KubeVirt reuses a host kubevirt and makes certain CRDs from it available inside
// the vCluster
type KubeVirt struct {
	// APIService holds information about where to find the virt-api service. Defaults
	// to virt-api/kubevirt.
	ApiService *APIService `json:"apiService,omitempty" yaml:"apiService,omitempty" mapstructure:"apiService,omitempty"`

	// Enabled signals if the integration should be enabled
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Sync holds configuration on what resources to sync
	Sync *KubeVirtSync `json:"sync,omitempty" yaml:"sync,omitempty" mapstructure:"sync,omitempty"`

	// Webhook holds configuration for enabling the webhook within the vCluster
	Webhook *EnableSwitch `json:"webhook,omitempty" yaml:"webhook,omitempty" mapstructure:"webhook,omitempty"`
}

// KubeVirtSync are the crds that are supported by this integration
type KubeVirtSync struct {
	// If DataVolumes should get synced
	DataVolumes *EnableSwitch `json:"dataVolumes,omitempty" yaml:"dataVolumes,omitempty" mapstructure:"dataVolumes,omitempty"`

	// If VirtualMachineClones should get synced
	VirtualMachineClones *EnableSwitch `json:"virtualMachineClones,omitempty" yaml:"virtualMachineClones,omitempty" mapstructure:"virtualMachineClones,omitempty"`

	// If VirtualMachineInstanceMigrations should get synced
	VirtualMachineInstanceMigrations *EnableSwitch `json:"virtualMachineInstanceMigrations,omitempty" yaml:"virtualMachineInstanceMigrations,omitempty" mapstructure:"virtualMachineInstanceMigrations,omitempty"`

	// If VirtualMachineInstances should get synced
	VirtualMachineInstances *EnableSwitch `json:"virtualMachineInstances,omitempty" yaml:"virtualMachineInstances,omitempty" mapstructure:"virtualMachineInstances,omitempty"`

	// If VirtualMachinePools should get synced
	VirtualMachinePools *EnableSwitch `json:"virtualMachinePools,omitempty" yaml:"virtualMachinePools,omitempty" mapstructure:"virtualMachinePools,omitempty"`

	// If VirtualMachines should get synced
	VirtualMachines *EnableSwitch `json:"virtualMachines,omitempty" yaml:"virtualMachines,omitempty" mapstructure:"virtualMachines,omitempty"`
}

type LabelSelector struct {
	// Labels defines what labels should be looked for
	Labels LabelSelectorLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Labels defines what labels should be looked for
type LabelSelectorLabels map[string]string

type LabelsAndAnnotations struct {
	// Annotations are extra annotations for this resource.
	Annotations LabelsAndAnnotationsAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels are extra labels for this resource.
	Labels LabelsAndAnnotationsLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Annotations are extra annotations for this resource.
type LabelsAndAnnotationsAnnotations map[string]string

// Labels are extra labels for this resource.
type LabelsAndAnnotationsLabels map[string]string

type LimitRange struct {
	// Annotations are extra annotations for this resource.
	Annotations LimitRangeAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Default are the default limits for the limit range
	Default LimitRangeDefault `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// DefaultRequest are the default request options for the limit range
	DefaultRequest LimitRangeDefaultRequest `json:"defaultRequest,omitempty" yaml:"defaultRequest,omitempty" mapstructure:"defaultRequest,omitempty"`

	// Enabled defines if the limit range should be deployed by vCluster. "auto" means
	// that if resourceQuota is enabled,
	// the limitRange will be enabled as well.
	Enabled interface{} `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Labels are extra labels for this resource.
	Labels LimitRangeLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Max are the max limits for the limit range
	Max LimitRangeMax `json:"max,omitempty" yaml:"max,omitempty" mapstructure:"max,omitempty"`

	// Min are the min limits for the limit range
	Min LimitRangeMin `json:"min,omitempty" yaml:"min,omitempty" mapstructure:"min,omitempty"`
}

// Annotations are extra annotations for this resource.
type LimitRangeAnnotations map[string]string

// Default are the default limits for the limit range
type LimitRangeDefault map[string]interface{}

// DefaultRequest are the default request options for the limit range
type LimitRangeDefaultRequest map[string]interface{}

// Labels are extra labels for this resource.
type LimitRangeLabels map[string]string

// Max are the max limits for the limit range
type LimitRangeMax map[string]interface{}

// Min are the min limits for the limit range
type LimitRangeMin map[string]interface{}

// MetricsServer reuses the metrics server from the host cluster within the
// vCluster.
type MetricsServer struct {
	// APIService holds information about where to find the metrics-server service.
	// Defaults to metrics-server/kube-system.
	ApiService *APIService `json:"apiService,omitempty" yaml:"apiService,omitempty" mapstructure:"apiService,omitempty"`

	// Enabled signals the metrics server integration should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Nodes defines if metrics-server nodes api should get proxied from host to
	// virtual cluster.
	Nodes *bool `json:"nodes,omitempty" yaml:"nodes,omitempty" mapstructure:"nodes,omitempty"`

	// Pods defines if metrics-server pods api should get proxied from host to virtual
	// cluster.
	Pods *bool `json:"pods,omitempty" yaml:"pods,omitempty" mapstructure:"pods,omitempty"`
}

type MutatingWebhook struct {
	// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
	// versions the Webhook expects.
	AdmissionReviewVersions []string `json:"admissionReviewVersions,omitempty" yaml:"admissionReviewVersions,omitempty" mapstructure:"admissionReviewVersions,omitempty"`

	// ClientConfig defines how to communicate with the hook.
	ClientConfig *ValidatingWebhookClientConfig `json:"clientConfig,omitempty" yaml:"clientConfig,omitempty" mapstructure:"clientConfig,omitempty"`

	// FailurePolicy defines how unrecognized errors from the admission endpoint are
	// handled -
	// allowed values are Ignore or Fail. Defaults to Fail.
	FailurePolicy *string `json:"failurePolicy,omitempty" yaml:"failurePolicy,omitempty" mapstructure:"failurePolicy,omitempty"`

	// MatchConditions is a list of conditions that must be met for a request to be
	// sent to this
	// webhook. Match conditions filter requests that have already been matched by the
	// rules,
	// namespaceSelector, and objectSelector. An empty list of matchConditions matches
	// all requests.
	// There are a maximum of 64 match conditions allowed.
	MatchConditions []interface{} `json:"matchConditions,omitempty" yaml:"matchConditions,omitempty" mapstructure:"matchConditions,omitempty"`

	// matchPolicy defines how the "rules" list is used to match incoming requests.
	// Allowed values are "Exact" or "Equivalent".
	MatchPolicy *string `json:"matchPolicy,omitempty" yaml:"matchPolicy,omitempty" mapstructure:"matchPolicy,omitempty"`

	// The name of the admission webhook.
	// Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
	// "imagepolicy" is the name of the webhook, and kubernetes.io is the name
	// of the organization.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// NamespaceSelector decides whether to run the webhook on an object based
	// on whether the namespace for that object matches the selector. If the
	// object itself is a namespace, the matching is performed on
	// object.metadata.labels. If the object is another cluster scoped resource,
	// it never skips the webhook.
	NamespaceSelector interface{} `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// ObjectSelector decides whether to run the webhook based on if the
	// object has matching labels. objectSelector is evaluated against both
	// the oldObject and newObject that would be sent to the webhook, and
	// is considered to match if either object matches the selector.
	ObjectSelector interface{} `json:"objectSelector,omitempty" yaml:"objectSelector,omitempty" mapstructure:"objectSelector,omitempty"`

	// reinvocationPolicy indicates whether this webhook should be called multiple
	// times as part of a single admission evaluation.
	// Allowed values are "Never" and "IfNeeded".
	ReinvocationPolicy *string `json:"reinvocationPolicy,omitempty" yaml:"reinvocationPolicy,omitempty" mapstructure:"reinvocationPolicy,omitempty"`

	// Rules describes what operations on what resources/subresources the webhook
	// cares about.
	// The webhook cares about an operation if it matches _any_ Rule.
	Rules []interface{} `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// SideEffects states whether this webhook has side effects.
	SideEffects *string `json:"sideEffects,omitempty" yaml:"sideEffects,omitempty" mapstructure:"sideEffects,omitempty"`

	// TimeoutSeconds specifies the timeout for this webhook.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type MutatingWebhookConfiguration struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" mapstructure:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Standard object metadata; More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
	Metadata *ObjectMeta `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Webhooks is a list of webhooks and the affected resources and operations.
	Webhooks []MutatingWebhook `json:"webhooks,omitempty" yaml:"webhooks,omitempty" mapstructure:"webhooks,omitempty"`
}

type NetworkPolicy struct {
	// Annotations are extra annotations for this resource.
	Annotations NetworkPolicyAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the network policy should be deployed by vCluster.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// FallbackDns corresponds to the JSON schema field "fallbackDns".
	FallbackDns *string `json:"fallbackDns,omitempty" yaml:"fallbackDns,omitempty" mapstructure:"fallbackDns,omitempty"`

	// Labels are extra labels for this resource.
	Labels NetworkPolicyLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// OutgoingConnections corresponds to the JSON schema field "outgoingConnections".
	OutgoingConnections *OutgoingConnections `json:"outgoingConnections,omitempty" yaml:"outgoingConnections,omitempty" mapstructure:"outgoingConnections,omitempty"`
}

// Annotations are extra annotations for this resource.
type NetworkPolicyAnnotations map[string]string

// Labels are extra labels for this resource.
type NetworkPolicyLabels map[string]string

type NetworkProxyKubelets struct {
	// ByHostname will add a special vCluster hostname to the nodes where the node can
	// be reached at. This doesn't work
	// for all applications, e.g. Prometheus requires a node IP.
	ByHostname *bool `json:"byHostname,omitempty" yaml:"byHostname,omitempty" mapstructure:"byHostname,omitempty"`

	// ByIP will create a separate service in the host cluster for every node that
	// will point to virtual cluster and will be used to
	// route traffic.
	ByIP *bool `json:"byIP,omitempty" yaml:"byIP,omitempty" mapstructure:"byIP,omitempty"`
}

type Networking struct {
	// Advanced holds advanced network options.
	Advanced *NetworkingAdvanced `json:"advanced,omitempty" yaml:"advanced,omitempty" mapstructure:"advanced,omitempty"`

	// ReplicateServices allows replicating services from the host within the virtual
	// cluster or the other way around.
	ReplicateServices *ReplicateServices `json:"replicateServices,omitempty" yaml:"replicateServices,omitempty" mapstructure:"replicateServices,omitempty"`

	// ResolveDNS allows to define extra DNS rules. This only works if embedded
	// coredns is configured.
	ResolveDNS []ResolveDNS `json:"resolveDNS,omitempty" yaml:"resolveDNS,omitempty" mapstructure:"resolveDNS,omitempty"`
}

type NetworkingAdvanced struct {
	// ClusterDomain is the Kubernetes cluster domain to use within the virtual
	// cluster.
	ClusterDomain *string `json:"clusterDomain,omitempty" yaml:"clusterDomain,omitempty" mapstructure:"clusterDomain,omitempty"`

	// FallbackHostCluster allows to fallback dns to the host cluster. This is useful
	// if you want to reach host services without
	// any other modification. You will need to provide a namespace for the service,
	// e.g. my-other-service.my-other-namespace
	FallbackHostCluster *bool `json:"fallbackHostCluster,omitempty" yaml:"fallbackHostCluster,omitempty" mapstructure:"fallbackHostCluster,omitempty"`

	// ProxyKubelets allows rewriting certain metrics and stats from the Kubelet to
	// "fake" this for applications such as
	// prometheus or other node exporters.
	ProxyKubelets *NetworkProxyKubelets `json:"proxyKubelets,omitempty" yaml:"proxyKubelets,omitempty" mapstructure:"proxyKubelets,omitempty"`
}

type ObjectMeta struct {
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata.
	Annotations ObjectMetaAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	Labels ObjectMetaLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Name must be unique within a namespace. Is required when creating resources,
	// although
	// some resources may allow a client to request the generation of an appropriate
	// name
	// automatically. Name is primarily intended for creation idempotence and
	// configuration
	// definition.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Annotations is an unstructured key value map stored with a resource that may be
// set by external tools to store and retrieve arbitrary metadata.
type ObjectMetaAnnotations map[string]string

// Map of string keys and values that can be used to organize and categorize
// (scope and select) objects. May match selectors of replication controllers
// and services.
type ObjectMetaLabels map[string]string

type OutgoingConnections struct {
	// IPBlock describes a particular CIDR (Ex. "192.168.1.0/24","2001:db8::/64") that
	// is allowed
	// to the pods matched by a NetworkPolicySpec's podSelector. The except entry
	// describes CIDRs
	// that should not be included within this rule.
	IpBlock *IPBlock `json:"ipBlock,omitempty" yaml:"ipBlock,omitempty" mapstructure:"ipBlock,omitempty"`

	// Platform enables egress access towards loft platform
	Platform *bool `json:"platform,omitempty" yaml:"platform,omitempty" mapstructure:"platform,omitempty"`
}

type Patch struct {
	// Conditions are conditions that must be true for
	// the patch to get executed
	Conditions []PatchCondition `json:"conditions,omitempty" yaml:"conditions,omitempty" mapstructure:"conditions,omitempty"`

	// FromPath is the path from the other object
	FromPath *string `json:"fromPath,omitempty" yaml:"fromPath,omitempty" mapstructure:"fromPath,omitempty"`

	// Ignore determines if the path should be ignored if handled as a reverse patch
	Ignore *bool `json:"ignore,omitempty" yaml:"ignore,omitempty" mapstructure:"ignore,omitempty"`

	// NamePath is the path to the name of a child resource within Path
	NamePath *string `json:"namePath,omitempty" yaml:"namePath,omitempty" mapstructure:"namePath,omitempty"`

	// NamespacePath is path to the namespace of a child resource within Path
	NamespacePath *string `json:"namespacePath,omitempty" yaml:"namespacePath,omitempty" mapstructure:"namespacePath,omitempty"`

	// Operation is the type of the patch
	Op *string `json:"op,omitempty" yaml:"op,omitempty" mapstructure:"op,omitempty"`

	// Path is the path of the patch
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Regex - is regular expresion used to identify the Name,
	// and optionally Namespace, parts of the field value that
	// will be replaced with the rewritten Name and/or Namespace
	Regex *string `json:"regex,omitempty" yaml:"regex,omitempty" mapstructure:"regex,omitempty"`

	// Sync defines if a specialized syncer should be initialized using values
	// from the rewriteName operation as Secret/Configmap names to be synced
	Sync *PatchSync `json:"sync,omitempty" yaml:"sync,omitempty" mapstructure:"sync,omitempty"`

	// Value is the new value to be set to the path
	Value interface{} `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type PatchCondition struct {
	// Empty means that the path value should be empty or unset
	Empty *bool `json:"empty,omitempty" yaml:"empty,omitempty" mapstructure:"empty,omitempty"`

	// Equal is the value the path should be equal to
	Equal interface{} `json:"equal,omitempty" yaml:"equal,omitempty" mapstructure:"equal,omitempty"`

	// NotEqual is the value the path should not be equal to
	NotEqual interface{} `json:"notEqual,omitempty" yaml:"notEqual,omitempty" mapstructure:"notEqual,omitempty"`

	// Path is the path within the object to select
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// SubPath is the path below the selected object to select
	SubPath *string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`
}

type PatchSync struct {
	// Configmap corresponds to the JSON schema field "configmap".
	Configmap *bool `json:"configmap,omitempty" yaml:"configmap,omitempty" mapstructure:"configmap,omitempty"`

	// Secret corresponds to the JSON schema field "secret".
	Secret *bool `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`
}

// PlatformAPIKey defines where to find the platform access key.
type PlatformAPIKey struct {
	// CreateRBAC will automatically create the necessary RBAC roles and role bindings
	// to allow vCluster to read the secret specified
	// in the above namespace, if specified.
	// This defaults to true.
	CreateRBAC *bool `json:"createRBAC,omitempty" yaml:"createRBAC,omitempty" mapstructure:"createRBAC,omitempty"`

	// Namespace defines the namespace where the access key secret should be retrieved
	// from. If this is not equal to the namespace
	// where the vCluster instance is deployed, you need to make sure vCluster has
	// access to this other namespace.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// SecretName is the name of the secret where the platform access key is stored.
	// This defaults to vcluster-platform-api-key if undefined.
	SecretName *string `json:"secretName,omitempty" yaml:"secretName,omitempty" mapstructure:"secretName,omitempty"`
}

// PlatformConfig holds platform configuration
type PlatformConfig struct {
	// APIKey defines where to find the platform access key and host. By default,
	// vCluster will search in the following locations in this precedence:
	// * environment variable called LICENSE
	// * secret specified under external.platform.apiKey.secretName
	// * secret called "vcluster-platform-api-key" in the vCluster namespace
	ApiKey *PlatformAPIKey `json:"apiKey,omitempty" yaml:"apiKey,omitempty" mapstructure:"apiKey,omitempty"`
}

type Plugin struct {
	// Args are the arguments that should be used for the init container
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Command is the command that should be used for the init container
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Config is the plugin config to use. This can be arbitrary config used for the
	// plugin.
	Config PluginConfig `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Env corresponds to the JSON schema field "env".
	Env []interface{} `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// EnvFrom corresponds to the JSON schema field "envFrom".
	EnvFrom []interface{} `json:"envFrom,omitempty" yaml:"envFrom,omitempty" mapstructure:"envFrom,omitempty"`

	// Image is the container image that should be used for the plugin
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy to use for the container image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Lifecycle corresponds to the JSON schema field "lifecycle".
	Lifecycle PluginLifecycle `json:"lifecycle,omitempty" yaml:"lifecycle,omitempty" mapstructure:"lifecycle,omitempty"`

	// LivenessProbe corresponds to the JSON schema field "livenessProbe".
	LivenessProbe PluginLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// Name is the name of the init-container and NOT the plugin name
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// RBAC holds additional rbac configuration for the plugin
	Rbac *PluginsRBAC `json:"rbac,omitempty" yaml:"rbac,omitempty" mapstructure:"rbac,omitempty"`

	// ReadinessProbe corresponds to the JSON schema field "readinessProbe".
	ReadinessProbe PluginReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// Resources are the container resources used for the init container
	Resources PluginResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// SecurityContext is the container security context used for the init container
	SecurityContext PluginSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// StartupProbe corresponds to the JSON schema field "startupProbe".
	StartupProbe PluginStartupProbe `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`

	// Version is the plugin version, this is only needed for legacy plugins.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`

	// VolumeMounts are extra volume mounts for the init container
	VolumeMounts []interface{} `json:"volumeMounts,omitempty" yaml:"volumeMounts,omitempty" mapstructure:"volumeMounts,omitempty"`

	// WorkingDir corresponds to the JSON schema field "workingDir".
	WorkingDir *string `json:"workingDir,omitempty" yaml:"workingDir,omitempty" mapstructure:"workingDir,omitempty"`
}

// Config is the plugin config to use. This can be arbitrary config used for the
// plugin.
type PluginConfig map[string]interface{}

type PluginLifecycle map[string]interface{}

type PluginLivenessProbe map[string]interface{}

type PluginReadinessProbe map[string]interface{}

// Resources are the container resources used for the init container
type PluginResources map[string]interface{}

// SecurityContext is the container security context used for the init container
type PluginSecurityContext map[string]interface{}

type PluginStartupProbe map[string]interface{}

type Plugins struct {
	// Args are the arguments that should be used for the init container
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Command is the command that should be used for the init container
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Config is the plugin config to use. This can be arbitrary config used for the
	// plugin.
	Config PluginsConfig `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Image is the container image that should be used for the plugin
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy to use for the container image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Name is the name of the init-container and NOT the plugin name
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// RBAC holds additional rbac configuration for the plugin
	Rbac *PluginsRBAC `json:"rbac,omitempty" yaml:"rbac,omitempty" mapstructure:"rbac,omitempty"`

	// Resources are the container resources used for the init container
	Resources PluginsResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// SecurityContext is the container security context used for the init container
	SecurityContext PluginsSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// VolumeMounts are extra volume mounts for the init container
	VolumeMounts []interface{} `json:"volumeMounts,omitempty" yaml:"volumeMounts,omitempty" mapstructure:"volumeMounts,omitempty"`
}

// Config is the plugin config to use. This can be arbitrary config used for the
// plugin.
type PluginsConfig map[string]interface{}

type PluginsExtraRules struct {
	// ExtraRules are extra rbac permissions roles that will be added to role or
	// cluster role
	ExtraRules []RBACPolicyRule `json:"extraRules,omitempty" yaml:"extraRules,omitempty" mapstructure:"extraRules,omitempty"`
}

type PluginsRBAC struct {
	// ClusterRole holds extra virtual cluster cluster role permissions required for
	// the plugin
	ClusterRole *PluginsExtraRules `json:"clusterRole,omitempty" yaml:"clusterRole,omitempty" mapstructure:"clusterRole,omitempty"`

	// Role holds extra virtual cluster role permissions for the plugin
	Role *PluginsExtraRules `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`
}

// Resources are the container resources used for the init container
type PluginsResources map[string]interface{}

// SecurityContext is the container security context used for the init container
type PluginsSecurityContext map[string]interface{}

// PodDNSConfig defines the DNS parameters of a pod in addition to those generated
// from DNSPolicy.
type PodDNSConfig struct {
	// A list of DNS name server IP addresses.
	// This will be appended to the base nameservers generated from DNSPolicy.
	// Duplicated nameservers will be removed.
	// +optional
	// +listType=atomic
	Nameservers []string `json:"nameservers,omitempty" yaml:"nameservers,omitempty" mapstructure:"nameservers,omitempty"`

	// A list of DNS resolver options.
	// This will be merged with the base options generated from DNSPolicy.
	// Duplicated entries will be removed. Resolution options given in Options
	// will override those that appear in the base DNSPolicy.
	// +optional
	// +listType=atomic
	Options []PodDNSConfigOption `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// A list of DNS search domains for host-name lookup.
	// This will be appended to the base search paths generated from DNSPolicy.
	// Duplicated search paths will be removed.
	// +optional
	// +listType=atomic
	Searches []string `json:"searches,omitempty" yaml:"searches,omitempty" mapstructure:"searches,omitempty"`
}

// PodDNSConfigOption defines DNS resolver options of a pod.
type PodDNSConfigOption struct {
	// Required.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// +optional
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type Policies struct {
	// CentralAdmission defines what validating or mutating webhooks should be
	// enforced within the virtual cluster.
	CentralAdmission *CentralAdmission `json:"centralAdmission,omitempty" yaml:"centralAdmission,omitempty" mapstructure:"centralAdmission,omitempty"`

	// LimitRange specifies limit range options.
	LimitRange *LimitRange `json:"limitRange,omitempty" yaml:"limitRange,omitempty" mapstructure:"limitRange,omitempty"`

	// NetworkPolicy specifies network policy options.
	NetworkPolicy *NetworkPolicy `json:"networkPolicy,omitempty" yaml:"networkPolicy,omitempty" mapstructure:"networkPolicy,omitempty"`

	// PodSecurityStandard that can be enforced can be one of: empty (""), baseline,
	// restricted or privileged
	PodSecurityStandard *string `json:"podSecurityStandard,omitempty" yaml:"podSecurityStandard,omitempty" mapstructure:"podSecurityStandard,omitempty"`

	// ResourceQuota specifies resource quota options.
	ResourceQuota *ResourceQuota `json:"resourceQuota,omitempty" yaml:"resourceQuota,omitempty" mapstructure:"resourceQuota,omitempty"`
}

type RBAC struct {
	// ClusterRole holds virtual cluster cluster role configuration
	ClusterRole *RBACClusterRole `json:"clusterRole,omitempty" yaml:"clusterRole,omitempty" mapstructure:"clusterRole,omitempty"`

	// Role holds virtual cluster role configuration
	Role *RBACRole `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`
}

type RBACClusterRole struct {
	// Enabled defines if the cluster role should be enabled or disabled. If auto,
	// vCluster automatically determines whether the virtual cluster requires a
	// cluster role.
	Enabled interface{} `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ExtraRules will add rules to the cluster role.
	ExtraRules []RBACClusterRoleExtraRulesElem `json:"extraRules,omitempty" yaml:"extraRules,omitempty" mapstructure:"extraRules,omitempty"`

	// OverwriteRules will overwrite the cluster role rules completely.
	OverwriteRules []RBACClusterRoleOverwriteRulesElem `json:"overwriteRules,omitempty" yaml:"overwriteRules,omitempty" mapstructure:"overwriteRules,omitempty"`
}

type RBACClusterRoleExtraRulesElem map[string]interface{}

type RBACClusterRoleOverwriteRulesElem map[string]interface{}

type RBACPolicyRule struct {
	// APIGroups is the name of the APIGroup that contains the resources.  If multiple
	// API groups are specified, any action requested against one of
	// the enumerated resources in any API group will be allowed. "" represents the
	// core API group and "*" represents all API groups.
	ApiGroups []string `json:"apiGroups,omitempty" yaml:"apiGroups,omitempty" mapstructure:"apiGroups,omitempty"`

	// NonResourceURLs is a set of partial urls that a user should have access to.  *s
	// are allowed, but only as the full, final step in the path
	// Since non-resource URLs are not namespaced, this field is only applicable for
	// ClusterRoles referenced from a ClusterRoleBinding.
	// Rules can either apply to API resources (such as "pods" or "secrets") or
	// non-resource URL paths (such as "/api"),  but not both.
	NonResourceURLs []string `json:"nonResourceURLs,omitempty" yaml:"nonResourceURLs,omitempty" mapstructure:"nonResourceURLs,omitempty"`

	// ResourceNames is an optional white list of names that the rule applies to.  An
	// empty set means that everything is allowed.
	ResourceNames []string `json:"resourceNames,omitempty" yaml:"resourceNames,omitempty" mapstructure:"resourceNames,omitempty"`

	// Resources is a list of resources this rule applies to. '*' represents all
	// resources.
	Resources []string `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this
	// rule. '*' represents all verbs.
	Verbs []string `json:"verbs,omitempty" yaml:"verbs,omitempty" mapstructure:"verbs,omitempty"`
}

type RBACRole struct {
	// Enabled defines if the role should be enabled or disabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ExtraRules will add rules to the role.
	ExtraRules []RBACRoleExtraRulesElem `json:"extraRules,omitempty" yaml:"extraRules,omitempty" mapstructure:"extraRules,omitempty"`

	// OverwriteRules will overwrite the role rules completely.
	OverwriteRules []RBACRoleOverwriteRulesElem `json:"overwriteRules,omitempty" yaml:"overwriteRules,omitempty" mapstructure:"overwriteRules,omitempty"`
}

type RBACRoleExtraRulesElem map[string]interface{}

type RBACRoleOverwriteRulesElem map[string]interface{}

type ReplicateServices struct {
	// FromHost defines the services that should get synced from the host to the
	// virtual cluster.
	FromHost []ServiceMapping `json:"fromHost,omitempty" yaml:"fromHost,omitempty" mapstructure:"fromHost,omitempty"`

	// ToHost defines the services that should get synced from virtual cluster to the
	// host cluster. If services are
	// synced to a different namespace than the virtual cluster is in, additional
	// permissions for the other namespace
	// are required.
	ToHost []ServiceMapping `json:"toHost,omitempty" yaml:"toHost,omitempty" mapstructure:"toHost,omitempty"`
}

type ResolveDNS struct {
	// Hostname is the hostname within the vCluster that should be resolved from.
	Hostname *string `json:"hostname,omitempty" yaml:"hostname,omitempty" mapstructure:"hostname,omitempty"`

	// Namespace is the virtual cluster namespace that should be resolved from.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Service is the virtual cluster service that should be resolved from.
	Service *string `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// Target is the DNS target that should get mapped to
	Target *ResolveDNSTarget `json:"target,omitempty" yaml:"target,omitempty" mapstructure:"target,omitempty"`
}

type ResolveDNSTarget struct {
	// HostNamespace to target
	HostNamespace *string `json:"hostNamespace,omitempty" yaml:"hostNamespace,omitempty" mapstructure:"hostNamespace,omitempty"`

	// HostService to target, format is hostNamespace/hostService
	HostService *string `json:"hostService,omitempty" yaml:"hostService,omitempty" mapstructure:"hostService,omitempty"`

	// Hostname to use as a DNS target
	Hostname *string `json:"hostname,omitempty" yaml:"hostname,omitempty" mapstructure:"hostname,omitempty"`

	// IP to use as a DNS target
	Ip *string `json:"ip,omitempty" yaml:"ip,omitempty" mapstructure:"ip,omitempty"`

	// VClusterService format is
	// hostNamespace/vClusterName/vClusterNamespace/vClusterService
	VClusterService *string `json:"vClusterService,omitempty" yaml:"vClusterService,omitempty" mapstructure:"vClusterService,omitempty"`
}

type ResourceQuota struct {
	// Annotations are extra annotations for this resource.
	Annotations ResourceQuotaAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the resource quota should be enabled. "auto" means that if
	// limitRange is enabled,
	// the resourceQuota will be enabled as well.
	Enabled interface{} `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Labels are extra labels for this resource.
	Labels ResourceQuotaLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Quota are the quota options
	Quota ResourceQuotaQuota `json:"quota,omitempty" yaml:"quota,omitempty" mapstructure:"quota,omitempty"`

	// ScopeSelector is the resource quota scope selector
	ScopeSelector ResourceQuotaScopeSelector `json:"scopeSelector,omitempty" yaml:"scopeSelector,omitempty" mapstructure:"scopeSelector,omitempty"`

	// Scopes are the resource quota scopes
	Scopes []string `json:"scopes,omitempty" yaml:"scopes,omitempty" mapstructure:"scopes,omitempty"`
}

// Annotations are extra annotations for this resource.
type ResourceQuotaAnnotations map[string]string

// Labels are extra labels for this resource.
type ResourceQuotaLabels map[string]string

// Quota are the quota options
type ResourceQuotaQuota map[string]interface{}

// ScopeSelector is the resource quota scope selector
type ResourceQuotaScopeSelector map[string]interface{}

type Resources struct {
	// Limits are resource limits for the container
	Limits ResourcesLimits `json:"limits,omitempty" yaml:"limits,omitempty" mapstructure:"limits,omitempty"`

	// Requests are minimal resources that will be consumed by the container
	Requests ResourcesRequests `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

// Limits are resource limits for the container
type ResourcesLimits map[string]interface{}

// Requests are minimal resources that will be consumed by the container
type ResourcesRequests map[string]interface{}

type RuleWithVerbs struct {
	// APIGroups is the API groups the resources belong to. '*' is all groups.
	ApiGroups []string `json:"apiGroups,omitempty" yaml:"apiGroups,omitempty" mapstructure:"apiGroups,omitempty"`

	// APIVersions is the API versions the resources belong to. '*' is all versions.
	ApiVersions []string `json:"apiVersions,omitempty" yaml:"apiVersions,omitempty" mapstructure:"apiVersions,omitempty"`

	// Verb is the kube verb associated with the request for API requests, not the
	// http verb. This includes things like list and watch.
	// For non-resource requests, this is the lowercase http verb.
	// If '*' is present, the length of the slice must be one.
	Operations []string `json:"operations,omitempty" yaml:"operations,omitempty" mapstructure:"operations,omitempty"`

	// Resources is a list of resources this rule applies to.
	Resources []string `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Scope specifies the scope of this rule.
	Scope *string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`
}

type Selector struct {
	// LabelSelector are the labels to select the object from
	LabelSelector SelectorLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`
}

// LabelSelector are the labels to select the object from
type SelectorLabelSelector map[string]string

type ServiceMapping struct {
	// From is the service that should get synced. Can be either in the form name or
	// namespace/name.
	From *string `json:"from,omitempty" yaml:"from,omitempty" mapstructure:"from,omitempty"`

	// To is the target service that it should get synced to. Can be either in the
	// form name or namespace/name.
	To *string `json:"to,omitempty" yaml:"to,omitempty" mapstructure:"to,omitempty"`
}

type ServiceMonitor struct {
	// Annotations are the extra annotations to add to the service monitor.
	Annotations ServiceMonitorAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled configures if Helm should create the service monitor.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Labels are the extra labels to add to the service monitor.
	Labels ServiceMonitorLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Annotations are the extra annotations to add to the service monitor.
type ServiceMonitorAnnotations map[string]string

// Labels are the extra labels to add to the service monitor.
type ServiceMonitorLabels map[string]string

// SleepMode holds configuration for native/workload only sleep mode
type SleepMode struct {
	// AutoSleep holds autoSleep details
	AutoSleep *SleepModeAutoSleep `json:"autoSleep,omitempty" yaml:"autoSleep,omitempty" mapstructure:"autoSleep,omitempty"`

	// AutoWakeup holds configuration for waking the vCluster on a schedule rather
	// than waiting for some activity.
	AutoWakeup *AutoWakeup `json:"autoWakeup,omitempty" yaml:"autoWakeup,omitempty" mapstructure:"autoWakeup,omitempty"`

	// Enabled toggles the sleep mode functionality, allowing for disabling sleep mode
	// without removing other config
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Timezone represents the timezone a sleep schedule should run against,
	// defaulting to UTC if unset
	TimeZone *string `json:"timeZone,omitempty" yaml:"timeZone,omitempty" mapstructure:"timeZone,omitempty"`
}

// SleepModeAutoSleep holds configuration for allowing a vCluster to sleep its
// workloads automatically
type SleepModeAutoSleep struct {
	// AfterInactivity represents how long a vCluster can be idle before workloads are
	// automaticaly put to sleep
	AfterInactivity *string `json:"afterInactivity,omitempty" yaml:"afterInactivity,omitempty" mapstructure:"afterInactivity,omitempty"`

	// Exclude holds configuration for labels that, if present, will prevent a
	// workload from going to sleep
	Exclude *AutoSleepExclusion `json:"exclude,omitempty" yaml:"exclude,omitempty" mapstructure:"exclude,omitempty"`

	// Schedule represents a cron schedule for when to sleep workloads
	Schedule *string `json:"schedule,omitempty" yaml:"schedule,omitempty" mapstructure:"schedule,omitempty"`
}

type StatefulSetImage struct {
	// Configure the registry of the container image, e.g. my-registry.com or ghcr.io
	// It defaults to ghcr.io and can be overriding either by using this field or
	// controlPlane.advanced.defaultImageRegistry
	Registry *string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Configure the repository of the container image, e.g. my-repo/my-image.
	// It defaults to the vCluster pro repository that includes the optional pro
	// modules that are turned off by default.
	// If you still want to use the pure OSS build, use 'loft-sh/vcluster-oss'
	// instead.
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`

	// Tag is the tag of the container image, e.g. latest
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

type Sync struct {
	// Configure what resources vCluster should sync from the host cluster to the
	// virtual cluster.
	FromHost *SyncFromHost `json:"fromHost,omitempty" yaml:"fromHost,omitempty" mapstructure:"fromHost,omitempty"`

	// Configure resources to sync from the virtual cluster to the host cluster.
	ToHost *SyncToHost `json:"toHost,omitempty" yaml:"toHost,omitempty" mapstructure:"toHost,omitempty"`
}

type SyncAllResource struct {
	// All defines if all resources of that type should get synced or only the
	// necessary ones that are needed.
	All *bool `json:"all,omitempty" yaml:"all,omitempty" mapstructure:"all,omitempty"`

	// Enabled defines if this option should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Patches patch the resource according to the provided specification.
	Patches []TranslatePatch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`
}

type SyncFromHost struct {
	// ConfigMaps defines if config maps in the host should get synced to the virtual
	// cluster.
	ConfigMaps *EnableSwitchWithResourcesMappings `json:"configMaps,omitempty" yaml:"configMaps,omitempty" mapstructure:"configMaps,omitempty"`

	// CSIDrivers defines if csi drivers should get synced from the host cluster to
	// the virtual cluster, but not back. If auto, is automatically enabled when the
	// virtual scheduler is enabled.
	CsiDrivers *EnableAutoSwitchWithPatches `json:"csiDrivers,omitempty" yaml:"csiDrivers,omitempty" mapstructure:"csiDrivers,omitempty"`

	// CSINodes defines if csi nodes should get synced from the host cluster to the
	// virtual cluster, but not back. If auto, is automatically enabled when the
	// virtual scheduler is enabled.
	CsiNodes *EnableAutoSwitchWithPatches `json:"csiNodes,omitempty" yaml:"csiNodes,omitempty" mapstructure:"csiNodes,omitempty"`

	// CSIStorageCapacities defines if csi storage capacities should get synced from
	// the host cluster to the virtual cluster, but not back. If auto, is
	// automatically enabled when the virtual scheduler is enabled.
	CsiStorageCapacities *EnableAutoSwitchWithPatches `json:"csiStorageCapacities,omitempty" yaml:"csiStorageCapacities,omitempty" mapstructure:"csiStorageCapacities,omitempty"`

	// CustomResources defines what custom resources should get synced read-only to
	// the virtual cluster from the host cluster. vCluster will automatically add any
	// required RBAC to the vCluster cluster role.
	CustomResources SyncFromHostCustomResources `json:"customResources,omitempty" yaml:"customResources,omitempty" mapstructure:"customResources,omitempty"`

	// Events defines if events should get synced from the host cluster to the virtual
	// cluster, but not back.
	Events *EnableSwitchWithPatches `json:"events,omitempty" yaml:"events,omitempty" mapstructure:"events,omitempty"`

	// IngressClasses defines if ingress classes should get synced from the host
	// cluster to the virtual cluster, but not back.
	IngressClasses *EnableSwitchWithPatches `json:"ingressClasses,omitempty" yaml:"ingressClasses,omitempty" mapstructure:"ingressClasses,omitempty"`

	// Nodes defines if nodes should get synced from the host cluster to the virtual
	// cluster, but not back.
	Nodes *SyncNodes `json:"nodes,omitempty" yaml:"nodes,omitempty" mapstructure:"nodes,omitempty"`

	// PriorityClasses defines if priority classes classes should get synced from the
	// host cluster to the virtual cluster, but not back.
	PriorityClasses *EnableSwitchWithPatches `json:"priorityClasses,omitempty" yaml:"priorityClasses,omitempty" mapstructure:"priorityClasses,omitempty"`

	// RuntimeClasses defines if runtime classes should get synced from the host
	// cluster to the virtual cluster, but not back.
	RuntimeClasses *EnableSwitchWithPatches `json:"runtimeClasses,omitempty" yaml:"runtimeClasses,omitempty" mapstructure:"runtimeClasses,omitempty"`

	// Secrets defines if secrets in the host should get synced to the virtual
	// cluster.
	Secrets *EnableSwitchWithResourcesMappings `json:"secrets,omitempty" yaml:"secrets,omitempty" mapstructure:"secrets,omitempty"`

	// StorageClasses defines if storage classes should get synced from the host
	// cluster to the virtual cluster, but not back. If auto, is automatically enabled
	// when the virtual scheduler is enabled.
	StorageClasses *EnableAutoSwitchWithPatches `json:"storageClasses,omitempty" yaml:"storageClasses,omitempty" mapstructure:"storageClasses,omitempty"`

	// VolumeSnapshotClasses defines if volume snapshot classes created within the
	// virtual cluster should get synced to the host cluster.
	VolumeSnapshotClasses *EnableSwitchWithPatches `json:"volumeSnapshotClasses,omitempty" yaml:"volumeSnapshotClasses,omitempty" mapstructure:"volumeSnapshotClasses,omitempty"`
}

type SyncFromHostCustomResource struct {
	// Enabled defines if this option should be enabled.
	Enabled bool `json:"enabled" yaml:"enabled" mapstructure:"enabled"`

	// Mappings for Namespace and Object
	Mappings *FromHostMappings `json:"mappings,omitempty" yaml:"mappings,omitempty" mapstructure:"mappings,omitempty"`

	// Patches patch the resource according to the provided specification.
	Patches []TranslatePatch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// Scope defines the scope of the resource
	Scope string `json:"scope" yaml:"scope" mapstructure:"scope"`
}

// CustomResources defines what custom resources should get synced read-only to the
// virtual cluster from the host cluster. vCluster will automatically add any
// required RBAC to the vCluster cluster role.
type SyncFromHostCustomResources map[string]SyncFromHostCustomResource

type SyncNodeSelector struct {
	// All specifies if all nodes should get synced by vCluster from the host to the
	// virtual cluster or only the ones where pods are assigned to.
	All *bool `json:"all,omitempty" yaml:"all,omitempty" mapstructure:"all,omitempty"`

	// Labels are the node labels used to sync nodes from host cluster to virtual
	// cluster. This will also set the node selector when syncing a pod from virtual
	// cluster to host cluster to the same value.
	Labels SyncNodeSelectorLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Labels are the node labels used to sync nodes from host cluster to virtual
// cluster. This will also set the node selector when syncing a pod from virtual
// cluster to host cluster to the same value.
type SyncNodeSelectorLabels map[string]string

type SyncNodes struct {
	// ClearImageStatus will erase the image status when syncing a node. This allows
	// to hide images that are pulled by the node.
	ClearImageStatus *bool `json:"clearImageStatus,omitempty" yaml:"clearImageStatus,omitempty" mapstructure:"clearImageStatus,omitempty"`

	// Enabled specifies if syncing real nodes should be enabled. If this is disabled,
	// vCluster will create fake nodes instead.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Patches patch the resource according to the provided specification.
	Patches []TranslatePatch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// Selector can be used to define more granular what nodes should get synced from
	// the host cluster to the virtual cluster.
	Selector *SyncNodeSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`

	// SyncBackChanges enables syncing labels and taints from the virtual cluster to
	// the host cluster. If this is enabled someone within the virtual cluster will be
	// able to change the labels and taints of the host cluster node.
	SyncBackChanges *bool `json:"syncBackChanges,omitempty" yaml:"syncBackChanges,omitempty" mapstructure:"syncBackChanges,omitempty"`
}

type SyncPods struct {
	// Enabled defines if pod syncing should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// EnforceTolerations will add the specified tolerations to all pods synced by the
	// virtual cluster.
	EnforceTolerations []string `json:"enforceTolerations,omitempty" yaml:"enforceTolerations,omitempty" mapstructure:"enforceTolerations,omitempty"`

	// Patches patch the resource according to the provided specification.
	Patches []TranslatePatch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// PriorityClassName is the priority class to set for synced pods.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// RewriteHosts is a special option needed to rewrite statefulset containers to
	// allow the correct FQDN. virtual cluster will add
	// a small container to each stateful set pod that will initially rewrite the
	// /etc/hosts file to match the FQDN expected by
	// the virtual cluster.
	RewriteHosts *SyncRewriteHosts `json:"rewriteHosts,omitempty" yaml:"rewriteHosts,omitempty" mapstructure:"rewriteHosts,omitempty"`

	// RuntimeClassName is the runtime class to set for synced pods.
	RuntimeClassName *string `json:"runtimeClassName,omitempty" yaml:"runtimeClassName,omitempty" mapstructure:"runtimeClassName,omitempty"`

	// TranslateImage maps an image to another image that should be used instead. For
	// example this can be used to rewrite
	// a certain image that is used within the virtual cluster to be another image on
	// the host cluster
	TranslateImage SyncPodsTranslateImage `json:"translateImage,omitempty" yaml:"translateImage,omitempty" mapstructure:"translateImage,omitempty"`

	// UseSecretsForSATokens will use secrets to save the generated service account
	// tokens by virtual cluster instead of using a
	// pod annotation.
	UseSecretsForSATokens *bool `json:"useSecretsForSATokens,omitempty" yaml:"useSecretsForSATokens,omitempty" mapstructure:"useSecretsForSATokens,omitempty"`
}

// TranslateImage maps an image to another image that should be used instead. For
// example this can be used to rewrite
// a certain image that is used within the virtual cluster to be another image on
// the host cluster
type SyncPodsTranslateImage map[string]string

type SyncRewriteHosts struct {
	// Enabled specifies if rewriting stateful set pods should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// InitContainer holds extra options for the init container used by vCluster to
	// rewrite the FQDN for stateful set pods.
	InitContainer *SyncRewriteHostsInitContainer `json:"initContainer,omitempty" yaml:"initContainer,omitempty" mapstructure:"initContainer,omitempty"`
}

type SyncRewriteHostsInitContainer struct {
	// Image is the image virtual cluster should use to rewrite this FQDN.
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Resources are the resources that should be assigned to the init container for
	// each stateful set init container.
	Resources *Resources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`
}

type SyncToHost struct {
	// ConfigMaps defines if config maps created within the virtual cluster should get
	// synced to the host cluster.
	ConfigMaps *SyncAllResource `json:"configMaps,omitempty" yaml:"configMaps,omitempty" mapstructure:"configMaps,omitempty"`

	// CustomResources defines what custom resources should get synced from the
	// virtual cluster to the host cluster. vCluster will copy the definition
	// automatically from host cluster to virtual cluster on startup.
	// vCluster will also automatically add any required RBAC permissions to the
	// vCluster role for this to work.
	CustomResources SyncToHostCustomResources `json:"customResources,omitempty" yaml:"customResources,omitempty" mapstructure:"customResources,omitempty"`

	// Endpoints defines if endpoints created within the virtual cluster should get
	// synced to the host cluster.
	Endpoints *EnableSwitchWithPatches `json:"endpoints,omitempty" yaml:"endpoints,omitempty" mapstructure:"endpoints,omitempty"`

	// Ingresses defines if ingresses created within the virtual cluster should get
	// synced to the host cluster.
	Ingresses *EnableSwitchWithPatches `json:"ingresses,omitempty" yaml:"ingresses,omitempty" mapstructure:"ingresses,omitempty"`

	// NetworkPolicies defines if network policies created within the virtual cluster
	// should get synced to the host cluster.
	NetworkPolicies *EnableSwitchWithPatches `json:"networkPolicies,omitempty" yaml:"networkPolicies,omitempty" mapstructure:"networkPolicies,omitempty"`

	// PersistentVolumeClaims defines if persistent volume claims created within the
	// virtual cluster should get synced to the host cluster.
	PersistentVolumeClaims *EnableSwitchWithPatches `json:"persistentVolumeClaims,omitempty" yaml:"persistentVolumeClaims,omitempty" mapstructure:"persistentVolumeClaims,omitempty"`

	// PersistentVolumes defines if persistent volumes created within the virtual
	// cluster should get synced to the host cluster.
	PersistentVolumes *EnableSwitchWithPatches `json:"persistentVolumes,omitempty" yaml:"persistentVolumes,omitempty" mapstructure:"persistentVolumes,omitempty"`

	// PodDisruptionBudgets defines if pod disruption budgets created within the
	// virtual cluster should get synced to the host cluster.
	PodDisruptionBudgets *EnableSwitchWithPatches `json:"podDisruptionBudgets,omitempty" yaml:"podDisruptionBudgets,omitempty" mapstructure:"podDisruptionBudgets,omitempty"`

	// Pods defines if pods created within the virtual cluster should get synced to
	// the host cluster.
	Pods *SyncPods `json:"pods,omitempty" yaml:"pods,omitempty" mapstructure:"pods,omitempty"`

	// PriorityClasses defines if priority classes created within the virtual cluster
	// should get synced to the host cluster.
	PriorityClasses *EnableSwitchWithPatches `json:"priorityClasses,omitempty" yaml:"priorityClasses,omitempty" mapstructure:"priorityClasses,omitempty"`

	// Secrets defines if secrets created within the virtual cluster should get synced
	// to the host cluster.
	Secrets *SyncAllResource `json:"secrets,omitempty" yaml:"secrets,omitempty" mapstructure:"secrets,omitempty"`

	// ServiceAccounts defines if service accounts created within the virtual cluster
	// should get synced to the host cluster.
	ServiceAccounts *EnableSwitchWithPatches `json:"serviceAccounts,omitempty" yaml:"serviceAccounts,omitempty" mapstructure:"serviceAccounts,omitempty"`

	// Services defines if services created within the virtual cluster should get
	// synced to the host cluster.
	Services *EnableSwitchWithPatches `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`

	// StorageClasses defines if storage classes created within the virtual cluster
	// should get synced to the host cluster.
	StorageClasses *EnableSwitchWithPatches `json:"storageClasses,omitempty" yaml:"storageClasses,omitempty" mapstructure:"storageClasses,omitempty"`

	// VolumeSnapshotContents defines if volume snapshot contents created within the
	// virtual cluster should get synced to the host cluster.
	VolumeSnapshotContents *EnableSwitchWithPatches `json:"volumeSnapshotContents,omitempty" yaml:"volumeSnapshotContents,omitempty" mapstructure:"volumeSnapshotContents,omitempty"`

	// VolumeSnapshots defines if volume snapshots created within the virtual cluster
	// should get synced to the host cluster.
	VolumeSnapshots *EnableSwitchWithPatches `json:"volumeSnapshots,omitempty" yaml:"volumeSnapshots,omitempty" mapstructure:"volumeSnapshots,omitempty"`
}

type SyncToHostCustomResource struct {
	// Enabled defines if this option should be enabled.
	Enabled bool `json:"enabled" yaml:"enabled" mapstructure:"enabled"`

	// Patches patch the resource according to the provided specification.
	Patches []TranslatePatch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// Scope defines the scope of the resource. If undefined, will use Namespaced.
	// Currently only Namespaced is supported.
	Scope *string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`
}

// CustomResources defines what custom resources should get synced from the virtual
// cluster to the host cluster. vCluster will copy the definition automatically
// from host cluster to virtual cluster on startup.
// vCluster will also automatically add any required RBAC permissions to the
// vCluster role for this to work.
type SyncToHostCustomResources map[string]SyncToHostCustomResource

type Telemetry struct {
	// Enabled specifies that the telemetry for the vCluster control plane should be
	// enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// InstanceCreator corresponds to the JSON schema field "instanceCreator".
	InstanceCreator *string `json:"instanceCreator,omitempty" yaml:"instanceCreator,omitempty" mapstructure:"instanceCreator,omitempty"`

	// MachineID corresponds to the JSON schema field "machineID".
	MachineID *string `json:"machineID,omitempty" yaml:"machineID,omitempty" mapstructure:"machineID,omitempty"`

	// PlatformInstanceID corresponds to the JSON schema field "platformInstanceID".
	PlatformInstanceID *string `json:"platformInstanceID,omitempty" yaml:"platformInstanceID,omitempty" mapstructure:"platformInstanceID,omitempty"`

	// PlatformUserID corresponds to the JSON schema field "platformUserID".
	PlatformUserID *string `json:"platformUserID,omitempty" yaml:"platformUserID,omitempty" mapstructure:"platformUserID,omitempty"`
}

type TranslatePatch struct {
	// Expression transforms the value according to the given JavaScript expression.
	Expression *string `json:"expression,omitempty" yaml:"expression,omitempty" mapstructure:"expression,omitempty"`

	// Labels treats the path value as a labels selector.
	Labels TranslatePatchLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Path is the path within the patch to target. If the path is not found within
	// the patch, the patch is not applied.
	Path string `json:"path" yaml:"path" mapstructure:"path"`

	// Reference treats the path value as a reference to another object and will
	// rewrite it based on the chosen mode
	// automatically. In single-namespace mode this will translate the name to
	// "vxxxxxxxxx" to avoid conflicts with
	// other names, in multi-namespace mode this will not translate the name.
	Reference *TranslatePatchReference `json:"reference,omitempty" yaml:"reference,omitempty" mapstructure:"reference,omitempty"`

	// ReverseExpression transforms the value according to the given JavaScript
	// expression.
	ReverseExpression *string `json:"reverseExpression,omitempty" yaml:"reverseExpression,omitempty" mapstructure:"reverseExpression,omitempty"`
}

type TranslatePatchLabels map[string]interface{}

type TranslatePatchReference struct {
	// APIVersion is the apiVersion of the referenced object.
	ApiVersion string `json:"apiVersion" yaml:"apiVersion" mapstructure:"apiVersion"`

	// APIVersionPath is optional relative path to use to determine the kind. If
	// APIVersionPath is not found, will fallback to apiVersion.
	ApiVersionPath *string `json:"apiVersionPath,omitempty" yaml:"apiVersionPath,omitempty" mapstructure:"apiVersionPath,omitempty"`

	// Kind is the kind of the referenced object.
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// KindPath is the optional relative path to use to determine the kind. If
	// KindPath is not found, will fallback to kind.
	KindPath *string `json:"kindPath,omitempty" yaml:"kindPath,omitempty" mapstructure:"kindPath,omitempty"`

	// NamePath is the optional relative path to the reference name within the object.
	NamePath *string `json:"namePath,omitempty" yaml:"namePath,omitempty" mapstructure:"namePath,omitempty"`

	// NamespacePath is the optional relative path to the reference namespace within
	// the object. If omitted or not found, namespacePath equals to the
	// metadata.namespace path of the object.
	NamespacePath *string `json:"namespacePath,omitempty" yaml:"namespacePath,omitempty" mapstructure:"namespacePath,omitempty"`
}

type ValidatingWebhook struct {
	// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
	// versions the Webhook expects.
	AdmissionReviewVersions []string `json:"admissionReviewVersions,omitempty" yaml:"admissionReviewVersions,omitempty" mapstructure:"admissionReviewVersions,omitempty"`

	// ClientConfig defines how to communicate with the hook.
	ClientConfig *ValidatingWebhookClientConfig `json:"clientConfig,omitempty" yaml:"clientConfig,omitempty" mapstructure:"clientConfig,omitempty"`

	// FailurePolicy defines how unrecognized errors from the admission endpoint are
	// handled -
	// allowed values are Ignore or Fail. Defaults to Fail.
	FailurePolicy *string `json:"failurePolicy,omitempty" yaml:"failurePolicy,omitempty" mapstructure:"failurePolicy,omitempty"`

	// MatchConditions is a list of conditions that must be met for a request to be
	// sent to this
	// webhook. Match conditions filter requests that have already been matched by the
	// rules,
	// namespaceSelector, and objectSelector. An empty list of matchConditions matches
	// all requests.
	// There are a maximum of 64 match conditions allowed.
	MatchConditions []interface{} `json:"matchConditions,omitempty" yaml:"matchConditions,omitempty" mapstructure:"matchConditions,omitempty"`

	// matchPolicy defines how the "rules" list is used to match incoming requests.
	// Allowed values are "Exact" or "Equivalent".
	MatchPolicy *string `json:"matchPolicy,omitempty" yaml:"matchPolicy,omitempty" mapstructure:"matchPolicy,omitempty"`

	// The name of the admission webhook.
	// Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
	// "imagepolicy" is the name of the webhook, and kubernetes.io is the name
	// of the organization.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// NamespaceSelector decides whether to run the webhook on an object based
	// on whether the namespace for that object matches the selector. If the
	// object itself is a namespace, the matching is performed on
	// object.metadata.labels. If the object is another cluster scoped resource,
	// it never skips the webhook.
	NamespaceSelector interface{} `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// ObjectSelector decides whether to run the webhook based on if the
	// object has matching labels. objectSelector is evaluated against both
	// the oldObject and newObject that would be sent to the webhook, and
	// is considered to match if either object matches the selector.
	ObjectSelector interface{} `json:"objectSelector,omitempty" yaml:"objectSelector,omitempty" mapstructure:"objectSelector,omitempty"`

	// Rules describes what operations on what resources/subresources the webhook
	// cares about.
	// The webhook cares about an operation if it matches _any_ Rule.
	Rules []interface{} `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// SideEffects states whether this webhook has side effects.
	SideEffects *string `json:"sideEffects,omitempty" yaml:"sideEffects,omitempty" mapstructure:"sideEffects,omitempty"`

	// TimeoutSeconds specifies the timeout for this webhook.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// ValidatingWebhookClientConfig contains the information to make a TLS connection
// with the webhook
type ValidatingWebhookClientConfig struct {
	// CABundle is a PEM encoded CA bundle which will be used to validate the
	// webhook's server certificate.
	// If unspecified, system trust roots on the apiserver are used.
	CaBundle *string `json:"caBundle,omitempty" yaml:"caBundle,omitempty" mapstructure:"caBundle,omitempty"`

	// Service is a reference to the service for this webhook. Either
	// `service` or `url` must be specified.
	//
	// If the webhook is running within the cluster, then you should use `service`.
	Service *ValidatingWebhookServiceReference `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// URL gives the location of the webhook, in standard URL form
	// (`scheme://host:port/path`). Exactly one of `url` or `service`
	// must be specified.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

type ValidatingWebhookConfiguration struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" mapstructure:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Standard object metadata; More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
	Metadata *ObjectMeta `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Webhooks is a list of webhooks and the affected resources and operations.
	Webhooks []ValidatingWebhook `json:"webhooks,omitempty" yaml:"webhooks,omitempty" mapstructure:"webhooks,omitempty"`
}

type ValidatingWebhookServiceReference struct {
	// Name is the name of the service.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace is the namespace of the service.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Path is an optional URL path which will be sent in any request to
	// this service.
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// If specified, the port on the service that hosting webhook.
	// Default to 443 for backward compatibility.
	// `port` should be a valid port number (1-65535, inclusive).
	Port *int `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
}

// Config is the vCluster config.
type Values struct {
	// Configure vCluster's control plane components and deployment.
	ControlPlane *ControlPlane `json:"controlPlane,omitempty" yaml:"controlPlane,omitempty" mapstructure:"controlPlane,omitempty"`

	// Experimental features for vCluster. Configuration here might change, so be
	// careful with this.
	Experimental *Experimental `json:"experimental,omitempty" yaml:"experimental,omitempty" mapstructure:"experimental,omitempty"`

	// ExportKubeConfig describes how vCluster should export the vCluster kubeConfig
	// file.
	ExportKubeConfig *ExportKubeConfig `json:"exportKubeConfig,omitempty" yaml:"exportKubeConfig,omitempty" mapstructure:"exportKubeConfig,omitempty"`

	// External holds configuration for tools that are external to the vCluster.
	External *ExternalConfig `json:"external,omitempty" yaml:"external,omitempty" mapstructure:"external,omitempty"`

	// Global values shared across all (sub)charts
	Global interface{} `json:"global,omitempty" yaml:"global,omitempty" mapstructure:"global,omitempty"`

	// Integrations holds config for vCluster integrations with other operators or
	// tools running on the host cluster
	Integrations *Integrations `json:"integrations,omitempty" yaml:"integrations,omitempty" mapstructure:"integrations,omitempty"`

	// Networking options related to the virtual cluster.
	Networking *Networking `json:"networking,omitempty" yaml:"networking,omitempty" mapstructure:"networking,omitempty"`

	// Plugin specifies which vCluster plugins to enable. Use "plugins" instead. Do
	// not use this option anymore.
	Plugin ValuesPlugin `json:"plugin,omitempty" yaml:"plugin,omitempty" mapstructure:"plugin,omitempty"`

	// Define which vCluster plugins to load.
	Plugins ValuesPlugins `json:"plugins,omitempty" yaml:"plugins,omitempty" mapstructure:"plugins,omitempty"`

	// Policies to enforce for the virtual cluster deployment as well as within the
	// virtual cluster.
	Policies *Policies `json:"policies,omitempty" yaml:"policies,omitempty" mapstructure:"policies,omitempty"`

	// Specifies whether to use vCluster Pro. This is automatically inferred in newer
	// versions. Do not use that option anymore.
	Pro *bool `json:"pro,omitempty" yaml:"pro,omitempty" mapstructure:"pro,omitempty"`

	// RBAC options for the virtual cluster.
	Rbac *RBAC `json:"rbac,omitempty" yaml:"rbac,omitempty" mapstructure:"rbac,omitempty"`

	// ServiceCIDR holds the service cidr for the virtual cluster. Do not use this
	// option anymore.
	ServiceCIDR *string `json:"serviceCIDR,omitempty" yaml:"serviceCIDR,omitempty" mapstructure:"serviceCIDR,omitempty"`

	// SleepMode holds the native sleep mode configuration for Pro clusters
	SleepMode *SleepMode `json:"sleepMode,omitempty" yaml:"sleepMode,omitempty" mapstructure:"sleepMode,omitempty"`

	// Sync describes how to sync resources from the virtual cluster to host cluster
	// and back.
	Sync *Sync `json:"sync,omitempty" yaml:"sync,omitempty" mapstructure:"sync,omitempty"`

	// Configuration related to telemetry gathered about vCluster usage.
	Telemetry *Telemetry `json:"telemetry,omitempty" yaml:"telemetry,omitempty" mapstructure:"telemetry,omitempty"`
}

type ValuesPlugin map[string]interface{}

type ValuesPlugin_0 map[string]interface{}

type ValuesPlugin_1 map[string]interface{}

type ValuesPlugin_2 map[string]interface{}

type ValuesPlugins map[string]interface{}

type ValuesPlugins_0 map[string]interface{}

type ValuesPlugins_1 map[string]interface{}

type ValuesPlugins_2 map[string]interface{}

type VirtualClusterKubeConfig struct {
	// ServerCAKey is the client ca cert path.
	ClientCACert *string `json:"clientCACert,omitempty" yaml:"clientCACert,omitempty" mapstructure:"clientCACert,omitempty"`

	// KubeConfig is the virtual cluster kubeconfig path.
	KubeConfig *string `json:"kubeConfig,omitempty" yaml:"kubeConfig,omitempty" mapstructure:"kubeConfig,omitempty"`

	// RequestHeaderCACert is the request header ca cert path.
	RequestHeaderCACert *string `json:"requestHeaderCACert,omitempty" yaml:"requestHeaderCACert,omitempty" mapstructure:"requestHeaderCACert,omitempty"`

	// ServerCAKey is the server ca cert path.
	ServerCACert *string `json:"serverCACert,omitempty" yaml:"serverCACert,omitempty" mapstructure:"serverCACert,omitempty"`

	// ServerCAKey is the server ca key path.
	ServerCAKey *string `json:"serverCAKey,omitempty" yaml:"serverCAKey,omitempty" mapstructure:"serverCAKey,omitempty"`
}

type VolumeClaim struct {
	// AccessModes are the persistent volume claim access modes.
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Enabled enables deploying a persistent volume claim. If auto, vCluster will
	// automatically determine
	// based on the chosen distro and other options if this is required.
	Enabled interface{} `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// RetentionPolicy is the persistent volume claim retention policy.
	RetentionPolicy *string `json:"retentionPolicy,omitempty" yaml:"retentionPolicy,omitempty" mapstructure:"retentionPolicy,omitempty"`

	// Size is the persistent volume claim storage size.
	Size *string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// StorageClass is the persistent volume claim storage class.
	StorageClass *string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

// VolumeMount describes a mounting of a Volume within a container.
type VolumeMount struct {
	// Path within the container at which the volume should be mounted.  Must
	// not contain ':'.
	MountPath *string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// mountPropagation determines how mounts are propagated from the host
	// to container and the other way around.
	// When not set, MountPropagationNone is used.
	// This field is beta in 1.10.
	MountPropagation *string `json:"mountPropagation,omitempty" yaml:"mountPropagation,omitempty" mapstructure:"mountPropagation,omitempty"`

	// This must match the Name of a Volume.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Mounted read-only if true, read-write otherwise (false or unspecified).
	// Defaults to false.
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`

	// Path within the volume from which the container's volume should be mounted.
	// Defaults to "" (volume's root).
	SubPath *string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`

	// Expanded path within the volume from which the container's volume should be
	// mounted.
	// Behaves similarly to SubPath but environment variable references $(VAR_NAME)
	// are expanded using the container's environment.
	// Defaults to "" (volume's root).
	// SubPathExpr and SubPath are mutually exclusive.
	SubPathExpr *string `json:"subPathExpr,omitempty" yaml:"subPathExpr,omitempty" mapstructure:"subPathExpr,omitempty"`
}
